import nodeUtil from 'util';
import nodeUrl from 'url';
import fetch from 'node-fetch';
import createDebug from 'debug';
import toughCookie from 'tough-cookie';
import cheerio from 'cheerio';
import nodeCrypto from 'crypto';
import nodeStream from 'stream';
import sandwichStream from 'sandwich-stream';
import nodeFs from 'fs';
import nodeHttp from 'http';
import nodeHttps from 'https';
import WebSocket from 'ws';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
var _core_1 = _core.version;

var _library = false;

var _shared = createCommonjsModule(function (module) {
var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: _core.version,
  mode: 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});
});

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');

var Symbol = _global.Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
};

$exports.store = store;
});

var f = _wks;

var _wksExt = {
	f: f
};

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

var document = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document) && _isObject(document.createElement);
var _domCreate = function (it) {
  return is ? document.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f$1 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f$1
};

var defineProperty = _objectDp.f;
var _wksDefine = function (name) {
  var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });
};

_wksDefine('asyncIterator');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Creates a key and value from the keys
 *
 * @param {string[]} keys
 *
 * @return {Object}
 */
const keyMirror = keys => {
  const out = {};

  for (const key of keys) {
    out[key] = key;
  }

  return out;
};
/**
 * Returns method for execute
 *
 * @param {string} method
 * @param {Object} params
 *
 * @return {string}
 */

const getExecuteMethod = (method, params = {}) => {
  const options = {};

  for (const [key, value] of Object.entries(params)) {
    options[key] = typeof value === 'object' ? String(value) : value;
  }

  return `API.${method}(${JSON.stringify(options)})`;
};
/**
 * Returns chain for execute
 *
 * @param {Array} methods
 *
 * @return {string}
 */

const getChainReturn = methods => `return [${methods.join(',')}];`;
/**
 * Resolve task
 *
 * @param {Array} tasks
 * @param {Array} results
 */

const resolveExecuteTask = (tasks, result) => {
  let errors = 0;
  result.response.forEach((response, i) => {
    if (response !== false) {
      tasks[i].resolve(response);
      return;
    }

    tasks[i].reject(result.errors[errors]);
    errors += 1;
  });
};
/**
 * Returns random ID
 *
 * @return {number}
 */

const getRandomId = () => `${Math.floor(Math.random() * 1e4)}${Date.now()}`;
/**
 * Delay N-ms
 *
 * @param {number} delayed
 *
 * @return {Promise}
 */

const delay = delayed => new Promise(resolve => setTimeout(resolve, delayed));
/**
 * Returns the unique keys
 *
 * @param {string[]} keys
 *
 * @return {string[]}
 */

const uniqueKeys = keys => [...new Set(keys)];
const lt = /&lt;/g;
const qt = /&gt;/g;
const br = /<br>/g;
const amp = /&amp;/g;
const quot = /&quot;/g;
/**
 * Decodes HTML entities
 *
 * @param {string} text
 *
 * @return {string}
 */

const unescapeHTML = text => text.replace(lt, '<').replace(qt, '>').replace(br, '\n').replace(amp, '&').replace(quot, '"');

const {
  inspect
} = nodeUtil;
class Request {
  /**
   * Constructor
   *
   * @param {string} method
   * @param {Object} params
   */
  constructor(method, params = {}) {
    this.method = method;
    this.params = params;
    this.attempts = 0;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Request';
  }
  /**
   * Adds attempt
   *
   * @return {number}
   */


  addAttempt() {
    this.attempts += 1;
  }
  /**
   * Returns string to execute
   *
   * @return {string}
   */


  toString() {
    return getExecuteMethod(this.method, this.params);
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      method,
      params,
      promise
    } = this;
    const payload = {
      method,
      params,
      promise
    };
    return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
  }

}

/**
 * List of VK API methods
 * Last updated: API v5.80 03.07.2018
 *
 * @type {Array}
 */
var methods = [
/**
 * Account
 * Methods for working with your account
 */
'account.ban', 'account.changePassword', 'account.getActiveOffers', 'account.getAppPermissions', 'account.getBanned', 'account.getCounters', 'account.getInfo', 'account.getProfileInfo', 'account.getPushSettings', 'account.registerDevice', 'account.saveProfileInfo', 'account.setInfo', 'account.setNameInMenu', 'account.setOffline', 'account.setOnline', 'account.setPushSettings', 'account.setSilenceMode', 'account.unban', 'account.unregisterDevice',
/**
 * AppWidgets
 * Methods for working with application widgets
 */
'appWidgets.getAppImageUploadServer', 'appWidgets.getAppImages', 'appWidgets.getGroupImageUploadServer', 'appWidgets.getGroupImages', 'appWidgets.getImagesById', 'appWidgets.saveAppImages', 'appWidgets.saveGroupImage', 'appWidgets.update',
/**
 * Ads
 * API for working with an advertising cabinet VK
 */
'ads.addOfficeUsers', 'ads.checkLink', 'ads.createAds', 'ads.createCampaigns', 'ads.createClients', 'ads.createLookalikeRequest', 'ads.createTargetGroup', 'ads.createTargetPixel', 'ads.deleteAds', 'ads.deleteCampaigns', 'ads.deleteClients', 'ads.deleteTargetGroup', 'ads.deleteTargetPixel', 'ads.getAccounts', 'ads.getAds', 'ads.getAdsLayout', 'ads.getAdsTargeting', 'ads.getBudget', 'ads.getCampaigns', 'ads.getCategories', 'ads.getClients', 'ads.getDemographics', 'ads.getFloodStats', 'ads.getLookalikeRequests', 'ads.getOfficeUsers', 'ads.getPostsReach', 'ads.getRejectionReason', 'ads.getStatistics', 'ads.getSuggestions', 'ads.getTargetGroups', 'ads.getTargetPixels', 'ads.getTargetingStats', 'ads.getUploadURL', 'ads.getVideoUploadURL', 'ads.importTargetContacts', 'ads.removeOfficeUsers', 'ads.removeTargetContacts', 'ads.saveLookalikeRequestResult', 'ads.shareTargetGroup', 'ads.updateAds', 'ads.updateCampaigns', 'ads.updateClients', 'ads.updateTargetGroup', 'ads.updateTargetPixel',
/**
 * Apps
 * Methods for working with applications
 */
'apps.deleteAppRequests', 'apps.get', 'apps.getCatalog', 'apps.getFriendsList', 'apps.getLeaderboard', 'apps.getScore', 'apps.sendRequest',
/**
 * Auth
 * Methods for working with authorization
 */
'auth.checkPhone', 'auth.confirm', 'auth.restore',
/**
 * Audio
 * Methods for working with audio
 */
'audio.get', 'audio.getById', 'audio.getLyrics', 'audio.search', 'audio.getUploadServer', 'audio.save', 'audio.add', 'audio.delete', 'audio.edit', 'audio.reorder', 'audio.restore', 'audio.getAlbums', 'audio.addAlbum', 'audio.editAlbum', 'audio.deleteAlbum', 'audio.moveToAlbum', 'audio.setBroadcast', 'audio.getBroadcastList', 'audio.getRecommendations', 'audio.getPopular', 'audio.getCount',
/**
 * Board
 * Methods for working with discussions
 */
'board.addTopic', 'board.closeTopic', 'board.createComment', 'board.deleteComment', 'board.deleteTopic', 'board.editComment', 'board.editTopic', 'board.fixTopic', 'board.getComments', 'board.getTopics', 'board.openTopic', 'board.restoreComment', 'board.unfixTopic',
/**
 * Database
 * Access to the database of educational institutions VK
 */
'database.getChairs', 'database.getCities', 'database.getCitiesById', 'database.getCountries', 'database.getCountriesById', 'database.getFaculties', 'database.getRegions', 'database.getSchoolClasses', 'database.getSchools', 'database.getUniversities',
/**
 * Docs
 * Methods for working with documents
 */
'docs.add', 'docs.delete', 'docs.edit', 'docs.get', 'docs.getById', 'docs.getMessagesUploadServer', 'docs.getTypes', 'docs.getUploadServer', 'docs.getWallUploadServer', 'docs.save', 'docs.search',
/**
 * Fave
 * Methods for working with bookmarks
 */
'fave.addGroup', 'fave.addLink', 'fave.addUser', 'fave.getLinks', 'fave.getMarketItems', 'fave.getPhotos', 'fave.getPosts', 'fave.getUsers', 'fave.getVideos', 'fave.removeGroup', 'fave.removeLink', 'fave.removeUser',
/**
 * Friends
 * Methods for working with friends
 */
'friends.add', 'friends.addList', 'friends.areFriends', 'friends.delete', 'friends.deleteAllRequests', 'friends.deleteList', 'friends.edit', 'friends.editList', 'friends.get', 'friends.getAppUsers', 'friends.getByPhones', 'friends.getLists', 'friends.getMutual', 'friends.getOnline', 'friends.getRecent', 'friends.getRequests', 'friends.getSuggestions', 'friends.search',
/**
 * Gifts
 * Methods for working with gifts
 */
'gifts.get',
/* Unofficially: */
'gifts.send', 'gifts.getCatalog',
/**
 * Groups
 * Methods for working with communities
 */
'groups.addCallbackServer', 'groups.addLink', 'groups.approveRequest', 'groups.ban', 'groups.create', 'groups.deleteCallbackServer', 'groups.deleteLink', 'groups.disableOnline', 'groups.edit', 'groups.editCallbackServer', 'groups.editLink', 'groups.editManager', 'groups.editPlace', 'groups.enableOnline', 'groups.get', 'groups.getBanned', 'groups.getById', 'groups.getCallbackConfirmationCode', 'groups.getCallbackServers', 'groups.getCallbackSettings', 'groups.getCatalog', 'groups.getCatalogInfo', 'groups.getInvitedUsers', 'groups.getInvites', 'groups.getLongPollServer', 'groups.getLongPollSettings', 'groups.getMembers', 'groups.getOnlineStatus', 'groups.getRequests', 'groups.getSettings', 'groups.getTokenPermissions', 'groups.invite', 'groups.isMember', 'groups.join', 'groups.leave', 'groups.removeUser', 'groups.reorderLink', 'groups.search', 'groups.setCallbackSettings', 'groups.setLongPollSettings', 'groups.unban',
/**
 * Leads
 * Management of advertising actions (offers)
 */
'leads.checkUser', 'leads.complete', 'leads.getStats', 'leads.getUsers', 'leads.metricHit', 'leads.start',
/**
 * Likes
 * Methods for working with the "I like"
 */
'likes.add', 'likes.delete', 'likes.getList', 'likes.isLiked',
/**
 * Market
 * Market methods allow you to work with products in communities
 */
'market.add', 'market.addAlbum', 'market.addToAlbum', 'market.createComment', 'market.delete', 'market.deleteAlbum', 'market.deleteComment', 'market.edit', 'market.editAlbum', 'market.editComment', 'market.get', 'market.getAlbumById', 'market.getAlbums', 'market.getById', 'market.getCategories', 'market.getComments', 'market.removeFromAlbum', 'market.reorderAlbums', 'market.reorderItems', 'market.report', 'market.reportComment', 'market.restore', 'market.restoreComment', 'market.search',
/**
 * Messages
 * Methods for working with personal messages
 */
'messages.addChatUser', 'messages.allowMessagesFromGroup', 'messages.createChat', 'messages.delete', 'messages.deleteChatPhoto', 'messages.deleteConversation', 'messages.denyMessagesFromGroup', 'messages.edit', 'messages.editChat', 'messages.getByConversationMessageId', 'messages.getById', 'messages.getChat', 'messages.getChatPreview', 'messages.getConversationMembers', 'messages.getConversations', 'messages.getConversationsById', 'messages.getHistory', 'messages.getHistoryAttachments', 'messages.getInviteLink', 'messages.getLastActivity', 'messages.getLongPollHistory', 'messages.getLongPollServer', 'messages.isMessagesFromGroupAllowed', 'messages.joinChatByInviteLink', 'messages.markAsAnsweredConversation', 'messages.markAsImportant', 'messages.markAsImportantConversation', 'messages.markAsRead', 'messages.pin', 'messages.removeChatUser', 'messages.restore', 'messages.search', 'messages.searchConversations', 'messages.send', 'messages.setActivity', 'messages.setChatPhoto', 'messages.unpin',
/**
 * On v5.80
 *
 * @deprecated
 */
'messages.get', 'messages.getDialogs', 'messages.getChatUsers', 'messages.searchDialogs', 'messages.deleteDialog', 'messages.markAsAnsweredDialog', 'messages.markAsImportantDialog',
/**
 * Newsfeed
 * Methods for working with the user's news feed
 */
'newsfeed.addBan', 'newsfeed.deleteBan', 'newsfeed.deleteList', 'newsfeed.get', 'newsfeed.getBanned', 'newsfeed.getComments', 'newsfeed.getLists', 'newsfeed.getMentions', 'newsfeed.getRecommended', 'newsfeed.getSuggestedSources', 'newsfeed.ignoreItem', 'newsfeed.saveList', 'newsfeed.search', 'newsfeed.unignoreItem', 'newsfeed.unsubscribe',
/**
 * Notes
 * Methods for working with notes
 */
'notes.add', 'notes.createComment', 'notes.delete', 'notes.deleteComment', 'notes.edit', 'notes.editComment', 'notes.get', 'notes.getById', 'notes.getComments', 'notes.restoreComment',
/**
 * Notifications
 * Methods for working with notifications
 */
'notifications.get', 'notifications.markAsViewed',
/**
 * Orders
 * Order management completed in applications
 */
'orders.cancelSubscription', 'orders.changeState', 'orders.get', 'orders.getAmount', 'orders.getById', 'orders.getUserSubscriptionById', 'orders.getUserSubscriptions', 'orders.updateSubscription',
/**
 * Pages
 * Methods for working with wiki pages
 */
'pages.clearCache', 'pages.get', 'pages.getHistory', 'pages.getTitles', 'pages.getVersion', 'pages.parseWiki', 'pages.save', 'pages.saveAccess',
/**
 * Photos
 * Methods for working with photos
 */
'photos.confirmTag', 'photos.copy', 'photos.createAlbum', 'photos.createComment', 'photos.delete', 'photos.deleteAlbum', 'photos.deleteComment', 'photos.edit', 'photos.editAlbum', 'photos.editComment', 'photos.get', 'photos.getAlbums', 'photos.getAlbumsCount', 'photos.getAll', 'photos.getAllComments', 'photos.getById', 'photos.getChatUploadServer', 'photos.getComments', 'photos.getMarketAlbumUploadServer', 'photos.getMarketUploadServer', 'photos.getMessagesUploadServer', 'photos.getNewTags', 'photos.getOwnerCoverPhotoUploadServer', 'photos.getOwnerPhotoUploadServer', 'photos.getTags', 'photos.getUploadServer', 'photos.getUserPhotos', 'photos.getWallUploadServer', 'photos.makeCover', 'photos.move', 'photos.putTag', 'photos.removeTag', 'photos.reorderAlbums', 'photos.reorderPhotos', 'photos.report', 'photos.reportComment', 'photos.restore', 'photos.restoreComment', 'photos.save', 'photos.saveMarketAlbumPhoto', 'photos.saveMarketPhoto', 'photos.saveMessagesPhoto', 'photos.saveOwnerCoverPhoto', 'photos.saveOwnerPhoto', 'photos.saveWallPhoto', 'photos.search',
/**
 * Places
 * Methods for working with places
 */
'places.add', 'places.checkin', 'places.getById', 'places.getCheckins', 'places.getTypes', 'places.search',
/**
 * Polls
 * Methods for working with polls
 */
'polls.addVote', 'polls.create', 'polls.deleteVote', 'polls.edit', 'polls.getById', 'polls.getVoters',
/**
 * Search
 * Methods for working with search
 */
'search.getHints',
/**
 * Secure
 * Administrative Methods
 */
'secure.addAppEvent', 'secure.checkToken', 'secure.getAppBalance', 'secure.getSMSHistory', 'secure.getTransactionsHistory', 'secure.getUserLevel', 'secure.sendNotification', 'secure.sendSMSNotification', 'secure.setCounter', 'secure.setUserLevel',
/**
 * Stats
 * Methods for working with statistics
 */
'stats.get', 'stats.getPostReach', 'stats.trackVisitor',
/**
 * Status
 * Methods for working with status
 */
'status.get', 'status.set',
/**
 * Storage
 * Methods for working with variables in an application
 */
'storage.get', 'storage.getKeys', 'storage.set',
/**
 * Stories
 * Methods for working with stories
 */
'stories.banOwner', 'stories.delete', 'stories.get', 'stories.getBanned', 'stories.getById', 'stories.getPhotoUploadServer', 'stories.getReplies', 'stories.getStats', 'stories.getVideoUploadServer', 'stories.getViewers', 'stories.hideAllReplies', 'stories.hideReply', 'stories.unbanOwner',
/**
 * Streaming
 * Methods for working with the Streaming API
 */
'streaming.getServerUrl', 'streaming.getSettings', 'streaming.getStats', 'streaming.setSettings',
/**
 * Users
 * Methods for working with user data
 */
'users.get', 'users.getFollowers', 'users.getNearby', 'users.getSubscriptions', 'users.isAppUser', 'users.report', 'users.search',
/**
 * Utils
 * Service methods
 */
'utils.checkLink', 'utils.deleteFromLastShortened', 'utils.getLastShortenedLinks', 'utils.getLinkStats', 'utils.getServerTime', 'utils.getShortLink', 'utils.resolveScreenName',
/**
 * Video
 * Methods for working with videos
 */
'video.add', 'video.addAlbum', 'video.addToAlbum', 'video.createComment', 'video.delete', 'video.deleteAlbum', 'video.deleteComment', 'video.edit', 'video.editAlbum', 'video.editComment', 'video.get', 'video.getAlbumById', 'video.getAlbums', 'video.getAlbumsByVideo', 'video.getCatalog', 'video.getCatalogSection', 'video.getComments', 'video.hideCatalogSection', 'video.removeFromAlbum', 'video.reorderAlbums', 'video.reorderVideos', 'video.report', 'video.reportComment', 'video.restore', 'video.restoreComment', 'video.save', 'video.search',
/* Unofficially: */
'video.getRecommendedLiveVideos',
/**
 * Wall
 * Methods for working with posts on the wall
 */
'wall.closeComments', 'wall.createComment', 'wall.delete', 'wall.deleteComment', 'wall.edit', 'wall.editAdsStealth', 'wall.editComment', 'wall.get', 'wall.getById', 'wall.getComments', 'wall.getReposts', 'wall.openComments', 'wall.pin', 'wall.post', 'wall.postAdsStealth', 'wall.reportComment', 'wall.reportPost', 'wall.repost', 'wall.restore', 'wall.restoreComment', 'wall.search', 'wall.unpin',
/**
 * Widgets
 * Methods for working with widgets on external sites
 */
'widgets.getComments', 'widgets.getPages'];

/**
 * General error class
 *
 * @public
 */
class VKError extends Error {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    code,
    message
  }) {
    super(message);
    this.code = code;
    this.message = message;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns property for json
   *
   * @return {Object}
   */


  toJSON() {
    const json = {};

    for (const key of Object.getOwnPropertyNames(this)) {
      json[key] = this[key];
    }

    return json;
  }

}

var version = "4.0.0-rc.0";

/**
 * VK API version
 *
 * @type {string}
 */

const API_VERSION = '5.80';
/**
 * Chat peer ID
 *
 * @type {number}
 */

const CHAT_PEER = 2e9;
/**
 * Base URL API
 *
 * @type {string}
 */

const BASE_URL_API = 'https://api.vk.com/method/';
/**
 * Blank html redirect
 *
 * @type {string}
 */

const CALLBACK_BLANK = 'https://oauth.vk.com/blank.html';
/**
 * User-Agent for standalone auth
 *
 * @type {string}
 */

const DESKTOP_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36';
/**
 * Minimum time interval api with error
 *
 * @type {number}
 */

const MINIMUM_TIME_INTERVAL_API = 1133;
/**
 * Default options
 *
 * @type {Object}
 *
 * @property {?string} [token]               Access token
 * @property {Agent}   [agent]               HTTPS agent
 * @property {?string} [lang]                The return data language
 *
 * @property {?string} [login]               User login (phone number or email)
 * @property {?string} [phone]               User phone number
 * @property {?string} [password]            User password
 *
 * @property {?number} [app]                 Application ID
 * @property {?number} [key]                 Secret application key
 * @property {?number} [scope]               List of permissions
 *
 * @property {string}  [apiMode]             Query mode (sequential|parallel|parallel_selected)
 * @property {number}  [apiWait]             Time to wait before re-querying
 * @property {number}  [apiLimit]            Requests per second
 * @property {number}  [apiTimeout]          Wait time for one request
 * @property {number}  [apiHeaders]          Headers sent to the API
 * @property {number}  [apiAttempts]         The number of retries at calling
 * @property {number}  [apiExecuteCount]     Number of requests per execute
 * @property {Array}   [apiExecuteMethods]   Methods for call execute (apiMode=parallel_selected)
 *
 * @property {number}  [uploadTimeout]       Wait time for one request
 *
 * @property {number}  [pollingWait]         Time to wait before re-querying
 * @property {number}  [pollingGroupId]      Group ID for polling
 * @property {number}  [pollingAttempts]     The number of retries at calling
 *
 * @property {?string} [webhookPath]         Webhook path
 * @property {?string} [webhookSecret]       Webhook secret key
 * @property {?string} [webhookConfirmation] Webhook confirmation key
 *
 * @property {number}  [collectAttempts]     The number of retries at calling
 */

const defaultOptions = {
  token: null,
  agent: null,
  lang: null,
  login: null,
  phone: null,
  password: null,
  app: null,
  key: null,
  scope: 'all',
  apiMode: 'sequential',
  apiWait: 3e3,
  apiLimit: 3,
  apiAttempts: 3,
  apiTimeout: 10e3,
  apiHeaders: {
    'User-Agent': `vk-io/${version} (+https://github.com/negezor/vk-io)`
  },
  apiExecuteCount: 25,
  apiExecuteMethods: ['messages.send'],
  uploadTimeout: 20e3,
  pollingWait: 3e3,
  pollingAttempts: 3,
  pollingGroupId: null,
  webhookPath: null,
  webhookSecret: null,
  webhookConfirmation: null,
  collectAttempts: 3
};
/**
 * Default extensions for attachments
 *
 * @type {Object}
 */

const defaultExtensions = {
  photo: 'jpg',
  video: 'mp4',
  audio: 'mp3',
  voice: 'ogg',
  graffiti: 'png'
};
/**
 * Default content type for attachments
 *
 * @type {Object}
 */

const defaultContentTypes = {
  photo: 'image/jpeg',
  video: 'video/mp4',
  audio: 'audio/mp3',
  voice: 'audio/ogg',
  graffiti: 'image/png'
};
/**
 * Sources of captcha
 *
 * @type {Object}
 */

const captchaTypes = keyMirror(['API', 'DIRECT_AUTH', 'IMPLICIT_FLOW_AUTH', 'ACCOUNT_VERIFICATION']);
/**
 * Message source
 *
 * @type {Object}
 */

const messageSources = {
  USER: 'user',
  CHAT: 'chat',
  GROUP: 'group',
  EMAIL: 'email'
};
/**
 * API error codes
 *
 * @type {Object}
 */

const apiErrors = {
  UNKNOWN_ERROR: 1,
  APP_SWITCHED_OFF: 2,
  UNKNOWN_METHOD: 3,
  AUTH_FAILURE: 5,
  TOO_MANY_REQUESTS: 6,
  SCOPE_NEEDED: 7,
  INCORRECT_REQUEST: 8,
  TOO_MANY_SIMILAR_ACTIONS: 9,
  INTERNAL_ERROR: 10,
  RESPONSE_SIZE_TOO_BIG: 13,
  CAPTCHA_REQUIRED: 14,
  ACCESS_DENIED: 15,
  USER_VALIDATION_REQUIRED: 17,
  PAGE_BLOCKED: 18,
  STANDALONE_ONLY: 20,
  STANDALONE_AND_OPEN_API_ONLY: 21,
  METHOD_DISABLED: 23,
  CONFIRMATION_REQUIRED: 24,
  GROUP_TOKEN_NOT_VALID: 27,
  APP_TOKEN_NOT_VALID: 28,
  WRONG_PARAMETER: 100,
  INCORRECT_USER_ID: 113,
  ALBUM_ACCESS_DENIED: 200,
  AUDIO_ACCESS_DENIED: 201,
  GROUP_ACCESS_DENIED: 203,
  ALBUM_OVERFLOW: 300,
  PAYMENTS_DISABLED: 500,
  COMMERCIAL_ACCESS_DENIED: 600,
  COMMERCIAL_ERROR: 603
};
/**
 * Auth error codes
 *
 * @type {Object}
 */

const authErrors = keyMirror(['PAGE_BLOCKED', 'INVALID_PHONE_NUMBER', 'AUTHORIZATION_FAILED', 'FAILED_PASSED_CAPTCHA', 'MISSING_CAPTCHA_HANDLER', 'FAILED_PASSED_TWO_FACTOR', 'MISSING_TWO_FACTOR_HANDLER']);
/**
 * Upload error codes
 *
 * @type {Object}
 */

const uploadErrors = keyMirror(['NO_FILES_TO_UPLOAD', 'EXCEEDED_MAX_FILES', 'UNSUPPORTED_SOURCE_TYPE']);
/**
 * Updates error codes
 *
 * @type {Object}
 */

const updatesErrors = keyMirror(['NEED_RESTART', 'POLLING_REQUEST_FAILED']);
/**
 * Collect error codes
 *
 * @type {Object}
 */

const collectErrors = keyMirror(['EXECUTE_ERROR']);
/**
 * Snippets error codes
 *
 * @type {Object}
 */

const snippetsErrors = keyMirror(['INVALID_URL', 'URL_NOT_ALLOWED', 'RESOURCE_NOT_FOUND']);
/**
 * Updates sources
 *
 * @type {Object}
 */

const updatesSources = keyMirror(['POLLING', 'WEBHOOK']);
/**
 * List of user permissions and their bit mask
 *
 * @type {Map}
 */

const userScopes = new Map([['notify', 1], ['friends', 2], ['photos', 4], ['audio', 8], ['video', 16], ['pages', 128], ['link', 256], ['status', 1024], ['notes', 2048], ['messages', 4096], ['wall', 8192], ['ads', 32768], ['offline', 65536], ['docs', 131072], ['groups', 262144], ['notifications', 524288], ['stats', 1048576], ['email', 4194304], ['market', 134217728]]);
/**
 * List of group permissions and their bit mask
 *
 * @type {Map}
 */

const groupScopes = new Map([['stories', 1], ['photos', 4], // ['app_widget', 64],
['messages', 4096], ['docs', 131072], ['manage', 262144]]);
/**
 * VK Platforms
 *
 * @type {Map}
 */

const platforms = new Map([[1, 'mobile'], [2, 'iphone'], [3, 'ipad'], [4, 'android'], [5, 'wphone'], [6, 'windows'], [7, 'web'], [8, 'standalone']]);
/**
 * Parse attachments with RegExp
 *
 * @type {RegExp}
 */

const parseAttachment = /(photo|video|audio|doc|wall|market)([-\d]+)_(\d+)_?(\d+)?/;
/**
 * Parse resource with RegExp
 *
 * @type {RegExp}
 */

const parseResource = /(app(?:lication)|id|club|public|albums|tag)([-\d]+)/;
/**
 * Parse owner resource with RegExp
 *
 * @type {RegExp}
 */

const parseOwnerResource = /(album|topic|wall|page|videos)([-\d]+)_(\d+)/;

const {
  CAPTCHA_REQUIRED,
  USER_VALIDATION_REQUIRED,
  CONFIRMATION_REQUIRED
} = apiErrors;
class APIError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor(payload) {
    const code = Number(payload.error_code);
    const message = `Code №${code} - ${payload.error_msg}`;
    super({
      code,
      message
    });
    this.params = payload.request_params;

    if (code === CAPTCHA_REQUIRED) {
      this.captchaSid = Number(payload.captcha_sid);
      this.captchaImg = payload.captcha_img;
    } else if (code === USER_VALIDATION_REQUIRED) {
      this.redirectUri = payload.redirect_uri;
    } else if (code === CONFIRMATION_REQUIRED) {
      this.confirmationText = payload.confirmation_text;
    }
  }

}

const {
  DEBUG = ''
} = process.env;
const isDebug = DEBUG.includes('vk-io:auth');
class AuthError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    message,
    code,
    pageHtml = null
  }) {
    super({
      message,
      code
    });
    this.pageHtml = isDebug ? pageHtml : null;
  }

}

class UploadError extends VKError {}

class CollectError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    message,
    code,
    errors
  }) {
    super({
      message,
      code
    });
    this.errors = errors;
  }

}

class UpdatesError extends VKError {}

class ExecuteError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor(payload) {
    const code = Number(payload.error_code);
    const message = `Code №${code} - ${payload.error_msg}`;
    super({
      code,
      message
    });
    this.method = payload.method;
  }

}

class SnippetsError extends VKError {}

class StreamingRuleError extends VKError {
  /**
   * Constructor
   *
   * @param {Object} payload
   */
  constructor({
    message,
    error_code: code
  }) {
    super({
      message,
      code
    });
  }

}

const {
  URL
} = nodeUrl;
/**
 * Returns the entire permission bit mask
 *
 * @return {number}
 */

const getAllUsersPermissions = () => Array.from(userScopes.values()).reduce((previous, current) => previous + current, 0);
/**
 * Returns the entire permission bit mask
 *
 * @return {number}
 */

const getAllGroupsPermissions = () => Array.from(groupScopes.values()).reduce((previous, current) => previous + current, 0);
/**
 * Returns the bit mask of the user permission by name
 *
 * @param {Array|string} scope
 *
 * @return {number}
 */

const getUsersPermissionsByName = scope => {
  if (!Array.isArray(scope)) {
    scope = scope.split(/,\s{0,}/);
  }

  let bitMask = 0;

  for (const name of scope) {
    if (userScopes.has(name)) {
      bitMask += userScopes.get(name);
    }
  }

  return bitMask;
};
/**
 * Returns the bit mask of the group permission by name
 *
 * @param {Array|string} scope
 *
 * @return {number}
 */

const getGroupsPermissionsByName = scope => {
  if (!Array.isArray(scope)) {
    scope = scope.split(/,\s{0,}/);
  }

  let bitMask = 0;

  for (const name of scope) {
    if (groupScopes.has(name)) {
      bitMask += groupScopes.get(name);
    }
  }

  return bitMask;
};
/**
 * Parse form
 *
 * @param {Cheerio} $
 *
 * @return {Object}
 */

const parseFormField = $ => {
  const $form = $('form[action][method]');
  const fields = {};

  for (const _ref of $form.serializeArray()) {
    const {
      name,
      value
    } = _ref;
    fields[name] = value;
  }

  return {
    action: $form.attr('action'),
    fields
  };
};
/**
 * Returns full URL use Response
 *
 * @param {string}   action
 * @param {Response} response
 *
 * @type {URL}
 */

const getFullURL = (action, {
  url
}) => {
  if (action.startsWith('https://')) {
    return new URL(action);
  }

  const {
    protocol,
    host
  } = new URL(url);
  return new URL(action, `${protocol}//${host}`);
};

const {
  promisify
} = nodeUtil;
const debug = createDebug('vk-io:util:fetch-cookie');
const REDIRECT_CODES = [303, 301, 302];
const {
  CookieJar
} = toughCookie;
const fetchCookieDecorator = (jar = new CookieJar()) => {
  const setCookie = promisify(jar.setCookie).bind(jar);
  const getCookieString = promisify(jar.getCookieString).bind(jar);
  return async function fetchCookie(url, options = {}) {
    const previousCookie = await getCookieString(url);
    const {
      headers = {}
    } = options;

    if (previousCookie) {
      headers.cookie = previousCookie;
    }

    debug('fetch url %s', url);
    const response = await fetch(url, _objectSpread({}, options, {
      headers
    }));
    const cookies = response.headers.raw()['set-cookie'] || [];

    if (cookies.length === 0) {
      return response;
    }

    await Promise.all(cookies.map(cookie => setCookie(cookie, response.url)));
    return response;
  };
};
const fetchCookieFollowRedirectsDecorator = jar => {
  const fetchCookie = fetchCookieDecorator(jar);
  return async function fetchCookieFollowRedirects(url, options = {}) {
    const response = await fetchCookie(url, _objectSpread({}, options, {
      redirect: 'manual'
    }));
    const isRedirect = REDIRECT_CODES.includes(response.status);

    if (isRedirect && options.redirect !== 'manual' && options.follow !== 0) {
      debug('Redirect to', response.headers.get('location'));
      let follow;

      if (options.follow) {
        follow = options.follow - 1;
      }

      return await fetchCookieFollowRedirects(response.headers.get('location'), {
        method: 'GET',
        body: null,
        follow
      });
    }

    return response;
  };
};

const {
  load: cheerioLoad
} = cheerio;
const {
  URL: URL$1,
  URLSearchParams
} = nodeUrl;
const debug$1 = createDebug('vk-io:auth:account-verification');
const {
  INVALID_PHONE_NUMBER,
  AUTHORIZATION_FAILED,
  FAILED_PASSED_CAPTCHA,
  MISSING_CAPTCHA_HANDLER,
  FAILED_PASSED_TWO_FACTOR,
  MISSING_TWO_FACTOR_HANDLER
} = authErrors;
/**
 * Two-factor auth check action
 *
 * @type {string}
 */

const ACTION_AUTH_CODE = 'act=authcheck';
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE = 'act=security';
/**
 * Bind a phone to a page
 *
 * @type {string}
 */

const ACTION_VALIDATE = 'act=validate';
/**
 * Bind a phone to a page action
 *
 * @type {string}
 */

const ACTION_CAPTCHA = 'act=captcha';
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS = 3;
class AccountVerification {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    const {
      agent,
      login,
      phone
    } = vk.options;
    this.agent = agent;
    this.login = login;
    this.phone = phone;
    this.jar = new CookieJar();
    this.fetchCookie = fetchCookieFollowRedirectsDecorator(this.jar);
    this.captcha = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'AccountVerification';
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, _objectSpread({}, options, {
      agent,
      compress: false,
      headers: _objectSpread({}, headers, {
        'User-Agent': DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run(redirectUri) {
    let response = await this.fetch(redirectUri, {
      method: 'GET'
    });
    const isProcessed = true;

    while (isProcessed) {
      const {
        url
      } = response;

      if (url.includes(CALLBACK_BLANK)) {
        let {
          hash
        } = new URL$1(response.url);

        if (hash.startsWith('#')) {
          hash = hash.substring(1);
        }

        const params = new URLSearchParams(hash);

        if (params.has('error')) {
          throw new AuthError({
            message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
            code: AUTHORIZATION_FAILED
          });
        }

        const user = params.get('user_id');
        return {
          user: user !== null ? Number(user) : null,
          token: params.get('access_token')
        };
      }

      const $ = cheerioLoad((await response.text()));

      if (url.includes(ACTION_AUTH_CODE)) {
        response = await this.processTwoFactorForm(response, $);
        continue;
      }

      if (url.includes(ACTION_SECURITY_CODE)) {
        response = await this.processSecurityForm(response, $);
        continue;
      }

      if (url.includes(ACTION_VALIDATE)) {
        response = await this.processValidateForm(response, $);
        continue;
      }

      if (url.includes(ACTION_CAPTCHA)) {
        response = await this.processCaptchaForm(response, $);
        continue;
      }

      throw new AuthError({
        message: 'Account verification failed',
        code: AUTHORIZATION_FAILED
      });
    }
  }
  /**
   * Process two-factor form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processTwoFactorForm(response, $) {
    debug$1('process two-factor handle');

    if (this.vk.twoFactorHandler === null) {
      throw new AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER
      });
    }

    let isProcessed = true;

    while (this.twoFactorAttempts < TWO_FACTOR_ATTEMPTS && isProcessed) {
      // eslint-disable-next-line no-loop-func
      await new Promise((resolve, reject) => {
        this.vk.twoFactorHandler({}, async code => {
          const {
            action,
            fields
          } = parseFormField($);
          fields.code = code;

          try {
            const url = getFullURL(action, response);
            response = await this.fetch(url, {
              method: 'POST',
              body: new URLSearchParams(fields)
            });
          } catch (error) {
            reject(error);
            throw error;
          }

          if (response.url.includes(ACTION_AUTH_CODE)) {
            resolve();
            throw new AuthError({
              message: 'Incorrect two-factor code',
              code: FAILED_PASSED_TWO_FACTOR
            });
          }

          isProcessed = false;
          resolve();
        });
      });
      this.twoFactorAttempts += 1;
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS && isProcessed) {
      throw new AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR
      });
    }

    return response;
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug$1('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = parseFormField($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = getFullURL(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE)) {
      throw new AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER
      });
    }

    return response;
  }
  /**
   * Process validation form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processValidateForm(response, $) {
    const href = $('#activation_wrap a').attr('href');
    const url = getFullURL(href, response);
    return await this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Process captcha form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processCaptchaForm(response, $) {
    if (this.vk.captchaHandler === null) {
      throw new AuthError({
        message: 'Missing captcha handler',
        code: MISSING_CAPTCHA_HANDLER
      });
    }

    if (this.captcha !== null) {
      this.captcha.reject(new AuthError({
        message: 'Incorrect captcha code',
        code: FAILED_PASSED_CAPTCHA
      }));
      this.captcha = null;
      this.captchaAttempts += 1;
    }

    const {
      action,
      fields
    } = parseFormField($);
    const src = $('.captcha_img').attr('src');
    const payload = {
      type: captchaTypes.ACCOUNT_VERIFICATION,
      sid: fields.captcha_sid,
      src
    };
    await new Promise((resolveCaptcha, rejectCaptcha) => {
      this.vk.captchaHandler(payload, key => new Promise((resolve, reject) => {
        if (key instanceof Error) {
          rejectCaptcha(key);
          reject(key);
          return;
        }

        fields.captcha_key = key;
        this.captcha = {
          resolve,
          reject
        };
        resolveCaptcha();
      }));
    });
    const url = getFullURL(action, response);
    url.searchParams.set('utf8', 1);
    return await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams(fields)
    });
  }

}

function sequential(next) {
  this.callMethod(this.queue.shift());
  next();
}

async function parallel(next) {
  const {
    queue
  } = this;

  if (queue[0].method.startsWith('execute')) {
    sequential.call(this, next);
    return;
  } // Wait next event loop, saves one request or more


  await delay(0);
  const {
    apiExecuteCount
  } = this.vk.options;
  const tasks = [];
  const chain = [];

  for (let i = 0; i < queue.length; i += 1) {
    if (queue[i].method.startsWith('execute')) {
      continue;
    }

    const request = queue.splice(i, 1)[0];
    i -= 1;
    tasks.push(request);
    chain.push(String(request));

    if (tasks.length >= apiExecuteCount) {
      break;
    }
  }

  try {
    const request = new Request('execute', {
      code: getChainReturn(chain)
    });
    this.callMethod(request);
    next();
    resolveExecuteTask(tasks, (await request.promise));
  } catch (error) {
    for (const task of tasks) {
      task.reject(error);
    }
  }
}

async function parallelSelected(next) {
  const {
    apiExecuteMethods,
    apiExecuteCount
  } = this.vk.options;
  const {
    queue
  } = this;

  if (!apiExecuteMethods.includes(queue[0].method)) {
    sequential.call(this, next);
    return;
  } // Wait next event loop, saves one request or more


  await delay(0);
  const tasks = [];
  const chain = [];

  for (let i = 0; i < queue.length; i += 1) {
    if (!apiExecuteMethods.includes(queue[i].method)) {
      continue;
    }

    const request = queue.splice(i, 1)[0];
    i -= 1;
    tasks.push(request);
    chain.push(String(request));

    if (tasks.length >= apiExecuteCount) {
      break;
    }
  }

  if (tasks.length === 0) {
    sequential.call(this, next);
    return;
  }

  try {
    const request = new Request('execute', {
      code: getChainReturn(chain)
    });
    this.callMethod(request);
    next();
    resolveExecuteTask(tasks, (await request.promise));
  } catch (error) {
    for (const task of tasks) {
      task.reject(error);
    }
  }
}

const {
  inspect: inspect$1
} = nodeUtil;
const {
  URL: URL$2,
  URLSearchParams: URLSearchParams$1
} = nodeUrl;
const {
  CAPTCHA_REQUIRED: CAPTCHA_REQUIRED$1,
  TOO_MANY_REQUESTS,
  USER_VALIDATION_REQUIRED: USER_VALIDATION_REQUIRED$1
} = apiErrors;
const debug$2 = createDebug('vk-io:api');
const requestHandlers = {
  sequential,
  parallel,
  parallel_selected: parallelSelected
};
/**
 * Returns request handler
 *
 * @param {string} mode
 *
 * @return {Function}
 */

const getRequestHandler = (mode = 'sequential') => {
  const handler = requestHandlers[mode];

  if (!handler) {
    throw new Error('Unsuported api mode');
  }

  return handler;
};

const baseUrlSymbol = Symbol('baseURLSymbol');
/**
 * Working with API methods
 *
 * @public
 */

class API {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.queue = [];
    this.started = false;
    this.suspended = false;
    this[baseUrlSymbol] = BASE_URL_API;

    for (const method of methods) {
      const [group, name] = method.split('.');

      if (!(group in this)) {
        this[group] = {};
      }

      this[group][name] = params => this.enqueue(method, params);
    }

    this.messages.send = (params = {}) => {
      if (!('random_id' in params)) {
        params.random_id = getRandomId();
      }

      return this.enqueue('messages.send', params);
    };
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'API';
  }
  /**
   * Returns the current used API version
   *
   * @return {string}
   */


  get API_VERSION() {
    return API_VERSION;
  }
  /**
   * Returns base URL
   *
   * @return {string}
   */


  get baseUrl() {
    return this[baseUrlSymbol];
  }
  /**
   * Sets base URL
   *
   * @param {string} url
   *
   * @return {string}
   */


  set baseUrl(url) {
    if (!url.endsWith('/')) {
      url += '/';
    }

    this[baseUrlSymbol] = url;
    return url;
  }
  /**
   * Checks that this is a API method
   *
   * @param {string} method
   *
   * @return {boolean}
   */


  isMethod(method) {
    return methods.includes(method);
  }
  /**
   * Call execute method
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  execute(params) {
    return this.enqueue('execute', params);
  }
  /**
   * Call execute procedure
   *
   * @param {string} name
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  procedure(name, params) {
    return this.enqueue(`execute.${name}`, params);
  }
  /**
   * Call raw method
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  call(method, params) {
    return this.enqueue(method, params);
  }
  /**
   * Adds request for queue
   *
   * @param {Request} request
   *
   * @return {Promise<Object>}
   */


  callWithRequest(request) {
    this.queue.push(request);
    this.worker();
    return request.promise;
  }
  /**
   * Adds method to queue
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  enqueue(method, params) {
    const request = new Request(method, params);
    return this.callWithRequest(request);
  }
  /**
   * Adds an element to the beginning of the queue
   *
   * @param {Request} request
   */


  requeue(request) {
    this.queue.unshift(request);
    this.worker();
  }
  /**
   * Running queue
   */


  worker() {
    if (this.started) {
      return;
    }

    this.started = true;
    const {
      apiLimit,
      apiMode
    } = this.vk.options;
    const handler = getRequestHandler(apiMode);
    const interval = Math.round(MINIMUM_TIME_INTERVAL_API / apiLimit);

    const work = async () => {
      if (this.queue.length === 0 || this.suspended) {
        this.started = false;
        return;
      }

      handler.call(this, () => {
        setTimeout(work, interval);
      });
    };

    work();
  }
  /**
   * Calls the api method
   *
   * @param {Object} request
   */


  async callMethod(request) {
    const {
      token,
      lang,
      agent,
      apiTimeout,
      apiHeaders
    } = this.vk.options;
    const {
      method
    } = request;

    try {
      const url = new URL$2(method, this.baseUrl);
      url.searchParams.set('access_token', token);
      url.searchParams.set('v', API_VERSION);

      if (lang !== null) {
        url.searchParams.append('lang', lang);
      }

      debug$2(`http --> ${method}`);
      const startTime = Date.now();
      let response = await fetch(url, {
        agent,
        method: 'POST',
        compress: false,
        timeout: apiTimeout,
        headers: _objectSpread({}, apiHeaders, {
          connection: 'keep-alive'
        }),
        body: new URLSearchParams$1(request.params)
      });
      response = await response.json();
      const endTime = (Date.now() - startTime).toLocaleString();
      debug$2(`http <-- ${method} ${endTime}ms`);

      if ('error' in response) {
        this.handleError(request, new APIError(response.error));
        return;
      }

      if ('captcha' in request) {
        request.captcha.resolve();
      }

      if (method.startsWith('execute')) {
        request.resolve({
          response: response.response,
          errors: (response.execute_errors || []).map(error => new ExecuteError(error))
        });
        return;
      }

      request.resolve('response' in response ? response.response : response);
    } catch (error) {
      const {
        apiWait,
        apiAttempts
      } = this.vk.options;

      if (request.addAttempt() <= apiAttempts) {
        setTimeout(() => {
          debug$2(`Request ${method} restarted ${request.attempts} times`);
          this.requeue(request);
        }, apiWait);
        return;
      }

      if ('captcha' in request) {
        request.captcha.reject(error);
      }

      request.reject(error);
    }
  }
  /**
   * Error API handler
   *
   * @param {Request} request
   * @param {Object} error
   */


  async handleError(request, error) {
    const {
      code
    } = error;

    if (code === TOO_MANY_REQUESTS) {
      if (this.suspended) {
        this.requeue(request);
        return;
      }

      this.suspended = true;
      await delay(MINIMUM_TIME_INTERVAL_API / this.vk.options.apiLimit + 50);
      this.suspended = false;
      this.requeue(request);
      return;
    }

    if ('captcha' in request) {
      request.captcha.reject(error);
    }

    if (code === USER_VALIDATION_REQUIRED$1) {
      if (this.suspended) {
        this.requeue(request);
      }

      this.suspended = true;

      try {
        const verification = new AccountVerification(this.vk);
        const {
          token
        } = await verification.run(error.redirectUri);
        debug$2('Account verification passed');
        this.vk.setToken(token);
        this.suspended = false;
        this.requeue(request);
      } catch (verificationError) {
        debug$2('Account verification error', verificationError);
        request.reject(error);
        await delay(15e3);
        this.suspended = false;
        this.worker();
      }

      return;
    }

    const isCaptcha = code === CAPTCHA_REQUIRED$1;

    if (isCaptcha && this.vk.captchaHandler === null || !isCaptcha) {
      request.reject(error);
      return;
    }

    const {
      captchaSid
    } = error;
    const payload = {
      type: captchaTypes.API,
      src: error.captchaImg,
      sid: captchaSid,
      request
    };
    this.vk.captchaHandler(payload, key => new Promise((resolve, reject) => {
      if (key instanceof Error) {
        request.reject(key);
        reject(key);
        return;
      }

      request.params.captcha_sid = captchaSid;
      request.params.captcha_key = key;
      request.captcha = {
        resolve,
        reject
      };
      this.requeue(request);
    }));
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$1.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      queue
    } = this;
    const payload = {
      started,
      queue
    };
    return `${options.stylize(name, 'special')} ${inspect$1(payload, options)}`;
  }

}

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var _redefine = createCommonjsModule(function (module) {
var SRC = _uid('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

_core.inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === _global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    _hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    _hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
});

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function (fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
};

var _strictMethod = function (method, arg) {
  return !!method && _fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

var $sort = [].sort;
var test = [1, 2, 3];

_export(_export.P + _export.F * (_fails(function () {
  // IE8-
  test.sort(undefined);
}) || !_fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !_strictMethod($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(_toObject(this))
      : $sort.call(_toObject(this), _aFunction(comparefn));
  }
});

const {
  load: cheerioLoad$1
} = cheerio;
const {
  URL: URL$3,
  URLSearchParams: URLSearchParams$2
} = nodeUrl;
const debug$3 = createDebug('vk-io:auth:direct');
const {
  INVALID_PHONE_NUMBER: INVALID_PHONE_NUMBER$1,
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$1,
  FAILED_PASSED_CAPTCHA: FAILED_PASSED_CAPTCHA$1,
  MISSING_CAPTCHA_HANDLER: MISSING_CAPTCHA_HANDLER$1,
  FAILED_PASSED_TWO_FACTOR: FAILED_PASSED_TWO_FACTOR$1,
  MISSING_TWO_FACTOR_HANDLER: MISSING_TWO_FACTOR_HANDLER$1
} = authErrors;
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS$1 = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */

const CAPTCHA_ATTEMPTS = 3;
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE$1 = 'act=security';
class DirectAuth {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, {
    app = vk.options.app,
    key = vk.options.key,
    agent = vk.options.agent,
    scope = vk.options.scope,
    login = vk.options.login,
    phone = vk.options.phone,
    password = vk.options.password
  } = {}) {
    this.vk = vk;
    this.app = app;
    this.key = key;
    this.agent = agent;
    this.scope = scope;
    this.login = login;
    this.phone = phone;
    this.password = password;
    this.started = false;
    this.captcha = null;
    this.twoFactor = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'DirectAuth';
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, _objectSpread({}, options, {
      agent,
      compress: false,
      headers: _objectSpread({}, headers, {
        'User-Agent': DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Returns permission page
   *
   * @param {Object} query
   *
   * @return {Response}
   */


  getPermissionsPage(query = {}) {
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = getAllUsersPermissions();
    } else if (typeof scope !== 'number') {
      scope = getUsersPermissionsByName(scope);
    }

    debug$3('auth scope %s', scope);
    const {
      app,
      key,
      login,
      phone,
      password
    } = this;
    const params = new URLSearchParams$2(_objectSpread({}, query, {
      username: login || phone,
      grant_type: 'password',
      client_secret: key,
      '2fa_supported': this.vk.twoFactorHandler !== null ? 1 : 0,
      v: API_VERSION,
      client_id: app,
      password,
      scope
    }));
    const url = new URL$3(`https://oauth.vk.com/token?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run() {
    if (this.started) {
      throw new AuthError({
        message: 'Authorization already started!',
        code: AUTHORIZATION_FAILED$1
      });
    }

    this.started = true;
    this.fetchCookie = fetchCookieFollowRedirectsDecorator();
    let response = await this.getPermissionsPage();
    let text;
    const isProcessed = true;

    while (isProcessed) {
      text = await response.text();
      let isJSON = true;

      try {
        text = JSON.parse(text);
      } catch (e) {
        isJSON = false;
      }

      if (isJSON) {
        if ('access_token' in text) {
          const {
            email = null,
            user_id: user = null,
            expires_in: expires = null,
            access_token: token
          } = text;
          return {
            email,
            user: user !== null ? Number(user) : null,
            token,
            expires: expires !== null ? Number(expires) : null
          };
        }

        if ('error' in text) {
          if (text.error === 'invalid_client') {
            throw new AuthError({
              message: `Invalid client (${text.error_description})`,
              code: AUTHORIZATION_FAILED$1
            });
          }

          if (text.error === 'need_captcha') {
            response = await this.processCaptcha(text);
            continue;
          }

          if (text.error === 'need_validation') {
            if ('validation_type' in text) {
              response = await this.processTwoFactor(text);
              continue;
            }

            const $ = cheerioLoad$1(text);
            response = this.processSecurityForm(response, $);
            continue;
          }

          throw new AuthError({
            message: 'Unsupported type validation',
            code: AUTHORIZATION_FAILED$1
          });
        }
      }

      throw new AuthError({
        message: 'Authorization failed',
        code: AUTHORIZATION_FAILED$1
      });
    }
  }
  /**
   * Process captcha
   *
   * @param {Object} payload
   *
   * @return {Response}
   */


  async processCaptcha({
    captcha_sid: sid,
    captcha_img: src
  }) {
    debug$3('captcha process');

    if (this.captcha !== null) {
      this.captcha.reject(new AuthError({
        message: 'Incorrect captcha code',
        code: FAILED_PASSED_CAPTCHA$1
      }));
      this.captcha = null;
      this.captchaAttempts += 1;
    }

    if (this.vk.captchaHandler === null) {
      throw new AuthError({
        message: 'Missing captcha handler',
        code: MISSING_CAPTCHA_HANDLER$1
      });
    }

    if (this.captchaAttempts >= CAPTCHA_ATTEMPTS) {
      throw new AuthError({
        message: 'Maximum attempts passage captcha',
        code: FAILED_PASSED_CAPTCHA$1
      });
    }

    const payload = {
      type: captchaTypes.DIRECT_AUTH,
      sid,
      src
    };
    const key = await new Promise((resolveCaptcha, rejectCaptcha) => {
      this.vk.captchaHandler(payload, code => new Promise((resolve, reject) => {
        if (code instanceof Error) {
          rejectCaptcha(code);
          reject(code);
          return;
        }

        this.captcha = {
          resolve,
          reject
        };
        resolveCaptcha(code);
      }));
    });
    return await this.getPermissionsPage({
      captcha_sid: sid,
      captcha_key: key
    });
  }
  /**
   * Process two-factor
   *
   * @param {Object} response
   *
   * @return {Promise<Response>}
   */


  async processTwoFactor({
    validation_type: validationType,
    phone_mask: phoneMask
  }) {
    debug$3('process two-factor handle');

    if (this.twoFactor !== null) {
      this.twoFactor.reject(new AuthError({
        message: 'Incorrect two-factor code',
        code: FAILED_PASSED_TWO_FACTOR$1
      }));
      this.twoFactor = null;
      this.twoFactorAttempts += 1;
    }

    if (this.vk.twoFactorHandler === null) {
      throw new AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER$1
      });
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS$1) {
      throw new AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR$1
      });
    }

    const type = validationType === '2fa_app' ? 'app' : 'sms';
    const key = await new Promise(resolveTwoFactor => {
      this.vk.twoFactorHandler({
        type,
        phoneMask
      }, code => new Promise((resolve, reject) => {
        this.twoFactor = {
          resolve,
          reject
        };
        resolveTwoFactor(code);
      }));
    });
    return await this.getPermissionsPage({
      code: key
    });
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug$3('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER$1
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = parseFormField($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = getFullURL(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams$2(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE$1)) {
      throw new AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER$1
      });
    }

    return response;
  }

}

const {
  load: cheerioLoad$2
} = cheerio;
const {
  URL: URL$4,
  URLSearchParams: URLSearchParams$3
} = nodeUrl;
const {
  promisify: promisify$1
} = nodeUtil;
const debug$4 = createDebug('vk-io:auth:implicit-flow');
const {
  PAGE_BLOCKED,
  INVALID_PHONE_NUMBER: INVALID_PHONE_NUMBER$2,
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$2,
  FAILED_PASSED_CAPTCHA: FAILED_PASSED_CAPTCHA$2,
  MISSING_CAPTCHA_HANDLER: MISSING_CAPTCHA_HANDLER$2,
  FAILED_PASSED_TWO_FACTOR: FAILED_PASSED_TWO_FACTOR$2,
  MISSING_TWO_FACTOR_HANDLER: MISSING_TWO_FACTOR_HANDLER$2
} = authErrors;
/**
 * Blocked action
 *
 * @type {string}
 */

const ACTION_BLOCKED = 'act=blocked';
/**
 * Two-factor auth check action
 *
 * @type {string}
 */

const ACTION_AUTH_CODE$1 = 'act=authcheck';
/**
 * Phone number check action
 *
 * @type {string}
 */

const ACTION_SECURITY_CODE$2 = 'act=security';
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */

const TWO_FACTOR_ATTEMPTS$2 = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */

const CAPTCHA_ATTEMPTS$1 = 3;
class ImplicitFlow {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, {
    app = vk.options.app,
    key = vk.options.key,
    agent = vk.options.agent,
    scope = vk.options.scope,
    login = vk.options.login,
    phone = vk.options.phone,
    password = vk.options.password
  } = {}) {
    this.vk = vk;
    this.app = app;
    this.key = key;
    this.agent = agent;
    this.scope = scope;
    this.login = login;
    this.phone = phone;
    this.password = password;
    this.jar = new CookieJar();
    this.started = false;
    this.captcha = null;
    this.captchaAttempts = 0;
    this.twoFactorAttempts = 0;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns CookieJar
   *
   * @return {CookieJar}
   */


  getCookieJar() {
    return this.jar;
  }
  /**
   * Sets the CookieJar
   *
   * @param {CookieJar} jar
   *
   * @return {this}
   */


  setCookieJar(jar) {
    this.jar = jar;
    return this;
  }
  /**
   * Returns cookie
   *
   * @return {Promise<Object>}
   */


  async getCookie() {
    const {
      jar
    } = this;
    const getCookieString = promisify$1(jar.getCookieString).bind(jar);
    const [login, main] = await Promise.all([getCookieString('https://login.vk.com'), getCookieString('https://vk.com')]);
    return {
      'login.vk.com': login,
      'vk.com': main
    };
  }
  /**
   * Executes the HTTP request
   *
   * @param {string} url
   * @param {Object} options
   *
   * @return {Promise<Response>}
   */


  fetch(url, options = {}) {
    const {
      agent
    } = this;
    const {
      headers = {}
    } = options;
    return this.fetchCookie(url, _objectSpread({}, options, {
      agent,
      compress: false,
      headers: _objectSpread({}, headers, {
        'User-Agent': DESKTOP_USER_AGENT
      })
    }));
  }
  /**
   * Runs authorization
   *
   * @return {Promise<Object>}
   */
  // eslint-disable-next-line consistent-return


  async run() {
    if (this.started) {
      throw new AuthError({
        message: 'Authorization already started!',
        code: AUTHORIZATION_FAILED$2
      });
    }

    this.started = true;
    this.fetchCookie = fetchCookieFollowRedirectsDecorator(this.jar);
    debug$4('get permissions page');
    let response = await this.getPermissionsPage();
    const isProcessed = true;

    while (isProcessed) {
      const {
        url
      } = response;
      debug$4('URL', url);

      if (url.includes(CALLBACK_BLANK)) {
        return {
          response
        };
      }

      if (url.includes(ACTION_BLOCKED)) {
        debug$4('page blocked');
        throw new AuthError({
          message: 'Page blocked',
          code: PAGE_BLOCKED
        });
      }

      const $ = cheerioLoad$2((await response.text()));

      if (url.includes(ACTION_AUTH_CODE$1)) {
        response = await this.processTwoFactorForm(response, $);
        continue;
      }

      if (url.includes(ACTION_SECURITY_CODE$2)) {
        response = await this.processSecurityForm(response, $);
        continue;
      }

      const $error = $('.box_error');
      const $service = $('.service_msg_warning');
      const isError = $error.length !== 0;

      if (this.captcha === null && (isError || $service.length !== 0)) {
        const errorText = isError ? $error.text() : $service.text();
        throw new AuthError({
          message: `Auth form error: ${errorText}`,
          code: AUTHORIZATION_FAILED$2,
          pageHtml: $.html()
        });
      }

      if (this.captcha !== null) {
        this.captcha.reject(new AuthError({
          message: 'Incorrect captcha code',
          code: FAILED_PASSED_CAPTCHA$2,
          pageHtml: $.html()
        }));
        this.captcha = null;
        this.captchaAttempts += 1;
      }

      if (this.captchaAttempts > CAPTCHA_ATTEMPTS$1) {
        throw new AuthError({
          message: 'Maximum attempts passage captcha',
          code: FAILED_PASSED_CAPTCHA$2
        });
      }

      if ($('input[name="pass"]').length !== 0) {
        debug$4('authorization form');
        response = await this.processAuthForm(response, $);
        continue;
      }

      if (url.includes('act=')) {
        throw new AuthError({
          message: 'Unsupported authorization event',
          code: AUTHORIZATION_FAILED$2,
          pageHtml: $.html()
        });
      }

      debug$4('auth with login & pass complete');

      if ($('form').length !== 0) {
        const {
          action
        } = parseFormField($);
        debug$4('url grant access', action);
        response = await this.fetch(action, {
          method: 'POST'
        });
      } else {
        const script = $('script[type="text/javascript"][language="javascript"]').text();
        const locations = script.match(/location\.href\s+=\s+"([^"]+)"/i);

        if (locations === null) {
          throw new AuthError({
            message: 'Could not log in',
            code: AUTHORIZATION_FAILED$2
          });
        }

        const location = locations[1].replace('&cancel=1', '');
        debug$4('url grant access', location);
        response = await this.fetch(location, {
          method: 'POST'
        });
      }
    }
  }
  /**
   * Process form auth
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processAuthForm(response, $) {
    debug$4('process login handle');
    const {
      login,
      password,
      phone
    } = this;
    const {
      action,
      fields
    } = parseFormField($);
    fields.email = login || phone;
    fields.pass = password;

    if ('captcha_sid' in fields) {
      if (this.vk.captchaHandler === null) {
        throw new AuthError({
          message: 'Missing captcha handler',
          code: MISSING_CAPTCHA_HANDLER$2
        });
      }

      const src = $('.oauth_captcha').attr('src') || $('#captcha').attr('src');
      const payload = {
        type: captchaTypes.IMPLICIT_FLOW_AUTH,
        sid: fields.captcha_sid,
        src
      };
      await new Promise((resolveCaptcha, rejectCaptcha) => {
        this.vk.captchaHandler(payload, key => new Promise((resolve, reject) => {
          if (key instanceof Error) {
            rejectCaptcha(key);
            reject(key);
            return;
          }

          fields.captcha_key = key;
          this.captcha = {
            resolve,
            reject
          };
          resolveCaptcha();
        }));
      });
    }

    debug$4('Fields', fields);
    const url = new URL$4(action);
    url.searchParams.set('utf8', 1);
    return await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams$3(fields)
    });
  }
  /**
   * Process two-factor form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processTwoFactorForm(response, $) {
    debug$4('process two-factor handle');

    if (this.vk.twoFactorHandler === null) {
      throw new AuthError({
        message: 'Missing two-factor handler',
        code: MISSING_TWO_FACTOR_HANDLER$2
      });
    }

    let isProcessed = true;

    while (this.twoFactorAttempts < TWO_FACTOR_ATTEMPTS$2 && isProcessed) {
      // eslint-disable-next-line no-loop-func
      await new Promise((resolve, reject) => {
        this.vk.twoFactorHandler({}, async code => {
          const {
            action,
            fields
          } = parseFormField($);
          fields.code = code;

          try {
            const url = getFullURL(action, response);
            response = await this.fetch(url, {
              method: 'POST',
              body: new URLSearchParams$3(fields)
            });
          } catch (error) {
            reject(error);
            throw error;
          }

          if (response.url.includes(ACTION_AUTH_CODE$1)) {
            resolve();
            throw new AuthError({
              message: 'Incorrect two-factor code',
              code: FAILED_PASSED_TWO_FACTOR$2,
              pageHtml: $.html()
            });
          }

          isProcessed = false;
          resolve();
        });
      });
      this.twoFactorAttempts += 1;
    }

    if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS$2 && isProcessed) {
      throw new AuthError({
        message: 'Failed passed two-factor authentication',
        code: FAILED_PASSED_TWO_FACTOR$2
      });
    }

    return response;
  }
  /**
   * Process security form
   *
   * @param {Response} response
   * @param {Cheerio}  $
   *
   * @return {Promise<Response>}
   */


  async processSecurityForm(response, $) {
    debug$4('process security form');
    const {
      login,
      phone
    } = this;
    let number;

    if (phone !== null) {
      number = phone;
    } else if (login !== null && !login.includes('@')) {
      number = login;
    } else {
      throw new AuthError({
        message: 'Missing phone number in the phone or login field',
        code: INVALID_PHONE_NUMBER$2,
        pageHtml: $.html()
      });
    }

    if (typeof number === 'string') {
      number = number.trim().replace(/^(\+|00)/, '');
    }

    number = String(number);
    const $field = $('.field_prefix');
    const prefix = $field.first().text().trim().replace('+', '').length;
    const postfix = $field.last().text().trim().length;
    const {
      action,
      fields
    } = parseFormField($);
    fields.code = number.slice(prefix, number.length - postfix);
    const url = getFullURL(action, response);
    response = await this.fetch(url, {
      method: 'POST',
      body: new URLSearchParams$3(fields)
    });

    if (response.url.includes(ACTION_SECURITY_CODE$2)) {
      throw new AuthError({
        message: 'Invalid phone number',
        code: INVALID_PHONE_NUMBER$2,
        pageHtml: $.html()
      });
    }

    return response;
  }

}

const {
  URL: URL$5,
  URLSearchParams: URLSearchParams$4
} = nodeUrl;
const debug$5 = createDebug('vk-io:auth:implicit-flow-user');
const {
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$3
} = authErrors;
class ImplicitFlowUser extends ImplicitFlow {
  /**
   * Returns permission page
   *
   * @return {Response}
   */
  getPermissionsPage() {
    const {
      app
    } = this;
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = getAllUsersPermissions();
    } else if (typeof scope !== 'number') {
      scope = getUsersPermissionsByName(scope);
    }

    debug$5('auth scope %s', scope);
    const params = new URLSearchParams$4({
      redirect_uri: CALLBACK_BLANK,
      response_type: 'token',
      display: 'page',
      v: API_VERSION,
      client_id: app,
      scope
    });
    const url = new URL$5(`https://oauth.vk.com/authorize?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Starts authorization
   *
   * @return {Promise<Object>}
   */


  async run() {
    const {
      response
    } = await super.run();
    let {
      hash
    } = new URL$5(response.url);

    if (hash.startsWith('#')) {
      hash = hash.substring(1);
    }

    const params = new URLSearchParams$4(hash);

    if (params.has('error')) {
      throw new AuthError({
        message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
        code: AUTHORIZATION_FAILED$3
      });
    }

    const user = params.get('user_id');
    const expires = params.get('expires_in');
    return {
      email: params.get('email'),
      user: user !== null ? Number(user) : null,
      token: params.get('access_token'),
      expires: expires !== null ? Number(expires) : null
    };
  }

}

const {
  URL: URL$6,
  URLSearchParams: URLSearchParams$5
} = nodeUrl;
const debug$6 = createDebug('vk-io:auth:implicit-flow-user');
const {
  AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$4
} = authErrors;
class ImplicitFlowGroups extends ImplicitFlow {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} options
   */
  constructor(vk, options) {
    super(vk, options);
    let {
      groups = null
    } = options;

    if (groups === null) {
      throw Error('Groups list must have');
    }

    if (!Array.isArray(groups)) {
      groups = [groups];
    }

    this.groups = groups.map(group => {
      if (typeof group !== 'number') {
        group = Number(group);
      }

      if (group < 0) {
        group = -group;
      }

      return group;
    });
  }
  /**
   * Returns permission page
   *
   * @param {Array} groups
   *
   * @return {Response}
   */


  getPermissionsPage() {
    const {
      app
    } = this;
    let {
      scope
    } = this;

    if (scope === 'all' || scope === null) {
      scope = getAllGroupsPermissions();
    } else if (typeof scope !== 'number') {
      scope = getGroupsPermissionsByName(scope);
    }

    debug$6('auth scope %s', scope);
    const params = new URLSearchParams$5({
      group_ids: this.groups.join(','),
      redirect_uri: CALLBACK_BLANK,
      response_type: 'token',
      display: 'page',
      v: API_VERSION,
      client_id: app,
      scope
    });
    const url = new URL$6(`https://oauth.vk.com/authorize?${params}`);
    return this.fetch(url, {
      method: 'GET'
    });
  }
  /**
   * Starts authorization
   *
   * @return {Promise<Array>}
   */


  async run() {
    const {
      response
    } = await super.run();
    let {
      hash
    } = new URL$6(response.url);

    if (hash.startsWith('#')) {
      hash = hash.substring(1);
    }

    const params = new URLSearchParams$5(hash);

    if (params.has('error')) {
      throw new AuthError({
        message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
        code: AUTHORIZATION_FAILED$4
      });
    }

    let expires = params.get('expires_in');

    if (expires !== null) {
      expires = Number(expires);
    }

    const tokens = [];

    for (const [name, value] of params) {
      if (!name.startsWith('access_token_')) {
        continue;
      }
      /* Example group access_token_XXXXX */


      const [,, group] = name.split('_');
      tokens.push({
        group: Number(group),
        token: value,
        expires
      });
    }

    return tokens;
  }

}

const {
  inspect: inspect$2
} = nodeUtil;
const {
  createHash
} = nodeCrypto;
const openAPIParams = ['expire', 'secret', 'mid', 'sid', 'sig'];
class Auth {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Auth';
  }
  /**
   * Standalone authorization with login & password
   *
   * @return {ImplicitFlowUser}
   */


  implicitFlowUser(options = {}) {
    return new ImplicitFlowUser(this.vk, options);
  }
  /**
   * Standalone authorization with login & password for group
   *
   * @param {mixed}  groups
   * @param {Object} options
   *
   * @return {ImplicitFlowGroup}
   */


  implicitFlowGroups(groups, options = {}) {
    return new ImplicitFlowGroups(this.vk, _objectSpread({}, options, {
      groups
    }));
  }
  /**
   * Direct authorization with login & login in user application
   *
   * @return {DirectAuth}
   */


  direct() {
    const {
      app,
      key
    } = this.vk.options;
    return new DirectAuth(this.vk, {
      app,
      key
    });
  }
  /**
   * Direct authorization with login & login in android application
   *
   * @return {DirectAuth}
   */


  androidApp() {
    return new DirectAuth(this.vk, {
      app: 2274003,
      key: 'hHbZxrka2uZ6jB1inYsH'
    });
  }
  /**
   * Direct authorization with login & login in windows application
   *
   * @return {DirectAuth}
   */


  windowsApp() {
    return new DirectAuth(this.vk, {
      app: 3697615,
      key: 'AlVXZFMUqyrnABp8ncuU'
    });
  }
  /**
   * Direct authorization with login & login in windows phone application
   *
   * @return {DirectAuth}
   */


  windowsPhoneApp() {
    return new DirectAuth(this.vk, {
      app: 3502557,
      key: 'PEObAuQi6KloPM4T30DV'
    });
  }
  /**
   * Direct authorization with login & login in iphone application
   *
   * @return {DirectAuth}
   */


  iphoneApp() {
    return new DirectAuth(this.vk, {
      app: 3140623,
      key: 'VeWdmVclDCtn6ihuP1nt'
    });
  }
  /**
   * Direct authorization with login & login in ipad application
   *
   * @return {DirectAuth}
   */


  ipadApp() {
    return new DirectAuth(this.vk, {
      app: 3682744,
      key: 'mY6CDUswIVdJLCD3j15n'
    });
  }
  /**
   * Verifies that the user is authorized through the Open API
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  async userAuthorizedThroughOpenAPI(params) {
    const paramsKeys = Object.keys(params).filter(key => openAPIParams.includes(key)).sort();
    let sign = '';

    for (const key of paramsKeys) {
      if (key !== 'sig') {
        sign += `${key}=${params[key]}`;
      }
    }

    sign += this.vk.options.key;
    sign = createHash('md5').update(sign).digest('hex');
    let authorized = false;
    const isNotExpire = params.expire > Date.now() / 1000;

    if (params.sig === sign && isNotExpire) {
      authorized = true;
    }

    return {
      authorized
    };
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$2.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} {}`;
  }

}

const {
  Stream
} = nodeStream;
/**
 * Check object is stream
 *
 * @param {Object} source
 *
 * @return {boolean}
 */

const isStream = source => typeof source === 'object' && source instanceof Stream;
/**
 * Copies object params to new object
 *
 * @param {Object} params
 * @param {Array}  properties
 *
 * @return {Object}
 */

const copyParams = (params, properties) => {
  const copies = {};

  for (const property of properties) {
    if (property in params) {
      copies[property] = params[property];
    }
  }

  return copies;
};

const {
  PassThrough
} = nodeStream;
const {
  SandwichStream
} = sandwichStream;
const CRNL = '\r\n';
class MultipartStream extends SandwichStream {
  /**
   * Constructor
   *
   * @param {string} boundary
   */
  constructor(boundary) {
    super({
      head: `--${boundary}${CRNL}`,
      tail: `${CRNL}--${boundary}--`,
      separator: `${CRNL}--${boundary}${CRNL}`
    });
    this.boundary = boundary;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'MultipartStream';
  }
  /**
   * Returns boundary
   *
   * @return {string}
   */


  getBoundary() {
    return this.boundary;
  }
  /**
   * Adds part
   *
   * @param {Object} part
   */


  addPart(part = {}) {
    const partStream = new PassThrough();

    if ('headers' in part) {
      for (const [key, header] of Object.entries(part.headers)) {
        partStream.write(`${key}:${header}${CRNL}`);
      }
    }

    partStream.write(CRNL);

    if (isStream(part.body)) {
      part.body.pipe(partStream);
    } else {
      partStream.end(part.body);
    }

    this.add(partStream);
  }
  /**
   * Adds form data
   *
   * @param {string} field
   * @param {mixed}  body
   * @param {Object} options
   */


  append(field, body, {
    filename = null,
    headers = {}
  }) {
    let header = `form-data; name="${field}"`;

    if (filename !== null) {
      header += `; filename="${filename}"`;
    }

    return this.addPart({
      headers: _objectSpread({}, headers, {
        'Content-Disposition': header
      }),
      body
    });
  }

}

const {
  inspect: inspect$3
} = nodeUtil;
class Attachment {
  /**
   * Constructor
   *
   * @param {string} type
   * @param {number} ownerId
   * @param {number} id
   * @param {string} accessKey
   */
  constructor(type, ownerId, id, accessKey = null) {
    this.type = type;
    this.ownerId = Number(ownerId);
    this.id = Number(id);
    this.accessKey = accessKey;
    this.$filled = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Parse attachment with string
   *
   * @param {string} attachment
   *
   * @return {Attachment}
   */


  static fromString(attachment) {
    if (!parseAttachment.test(attachment)) {
      throw new Error('Incorrect attachment');
    }

    const [, type, ownerId, id, accessKey] = attachment.match(parseAttachment);
    return new Attachment(type, ownerId, id, accessKey);
  }
  /**
   * Returns whether the attachment is filled
   *
   * @return {boolean}
   */


  get isFilled() {
    return this.$filled;
  }
  /**
   * Checks that the attachment is equivalent with object
   *
   * @param {Attachment} attachment
   *
   * @return {boolean}
   */


  equals(attachment) {
    if (!attachment) {
      return false;
    }

    if (this.type !== attachment.type) {
      return false;
    }

    if (this.ownerId !== attachment.ownerId) {
      return false;
    }

    if (this.id !== attachment.id) {
      return false;
    }

    return true;
  }
  /**
   * Checks that the attachment is equivalent with string
   *
   * @param {string} attachment
   *
   * @return {boolean}
   */


  equalString(attachment) {
    return this.equals(Attachment.fromString(attachment));
  }
  /**
   * Returns a string to attach a VK
   *
   * @return {string}
   */


  toString() {
    const accessKey = this.accessKey !== null ? `_${this.accessKey}` : '';
    return `${this.type}${this.ownerId}_${this.id}${accessKey}`;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$3.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const payload = this.$filled ? ` ${inspect$3(this.payload, options)} ` : '';
    return `${options.stylize(name, 'special')} { ${options.stylize(this, 'string')} ${payload}}`;
  }

}

const {
  inspect: inspect$4
} = nodeUtil;
class ExternalAttachment {
  /**
   * Constructor
   *
   * @param {string} type
   * @param {Object} payload
   */
  constructor(type, payload) {
    this.type = type;
    this.payload = payload;
    this.$filled = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns whether the attachment is filled
   *
   * @return {boolean}
   */


  get isFilled() {
    return this.$filled;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$4.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const payload = this.$filled ? ` ${inspect$4(this.payload, options)} ` : '';
    return `${options.stylize(name, 'special')} { ${options.stylize(this, 'string')} ${payload}}`;
  }

}

class GiftAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('gift', payload);
    this.vk = vk;
  }
  /**
   * Returns the identifier gift
   *
   * @return {number}
   */


  get id() {
    return this.payload.id;
  }

}

// eslint-disable-next-line import/no-cycle
const attachmentsTypes = {
  gift: () => GiftAttachment,
  wall: () => WallAttachment,
  link: () => LinkAttachment,
  photo: () => PhotoAttachment,
  audio: () => AudioAttachment,
  video: () => VideoAttachment,
  doc: () => DocumentAttachment,
  market: () => MarketAttachment,
  sticker: () => StickerAttachment,
  wall_reply: () => WallReplyAttachment,
  market_album: () => MarketAlbumAttachment
};
/**
 * Transform raw attachments to wrapper
 *
 * @param {Object[]} attachments
 * @param {VK}       vk
 *
 * @return {Object[]}
 */
// eslint-disable-next-line import/prefer-default-export

const transformAttachments = (attachments = [], vk) => attachments.map(item => {
  const {
    type
  } = item;
  const attachment = attachmentsTypes[type];
  return attachment ? new (attachment())(item[type], vk) : false;
}).filter(Boolean);

class WallAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('wall', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.attachments = transformAttachments(payload.attachments);
    this.$filled = 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const [post] = await this.vk.api.wall.getById({
      posts: `${this.ownerId}_${this.id}`,
      extended: 0
    });
    this.payload = post;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }
  /**
   * Checks has comments
   *
   * @return {?boolean}
   */


  get hasComments() {
    if (!this.$filled) {
      return null;
    }

    return this.payload.comments.count > 0;
  }
  /**
   * Checks has ads in post
   *
   * @return {?boolean}
   */


  get hasAds() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.marked_as_ads);
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.getType() === type);
  }
  /**
   * Checks has this user reposted
   *
   * @return {?boolean}
   */


  get hasUserReposted() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.reposts.user_reposted);
  }
  /**
   * Checks has this user likes
   *
   * @return {?boolean}
   */


  get hasUserLike() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.user_likes);
  }
  /**
   * Checks can the current user comment on the entry
   *
   * @return {?boolean}
   */


  get isCanUserCommented() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.comments.can_post);
  }
  /**
   * Checks if a community can comment on a post
   *
   * @return {?boolean}
   */


  get isCanGroupsCommented() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.comments.groups_can_post);
  }
  /**
   * Checks if you can comment on a post
   *
   * @return {?boolean}
   */


  get isCanCommented() {
    return this.isCanUserCommented() || this.isCanGroupsCommented();
  }
  /**
   * Checks whether the current user can like the record
   *
   * @return {?boolean}
   */


  get isCanLike() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.likes.can_like);
  }
  /**
   * hecks whether the current user can repost the record
   *
   * @return {?boolean}
   */


  get isCanReposted() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.likes.can_publish);
  }
  /**
   * Checks is can this user pin post
   *
   * @return {?boolean}
   */


  get isCanPin() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.can_pin);
  }
  /**
   * Checks is can this user delete post
   *
   * @return {?boolean}
   */


  get isCanDelete() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.can_delete);
  }
  /**
   * Checks is can this user edit post
   *
   * @return {?boolean}
   */


  get isCanEdit() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.can_edit);
  }
  /**
   * Checks is can this user edit post
   *
   * @return {?boolean}
   */


  get isPinned() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.is_pinned);
  }
  /**
   * Checks is post created only by friends
   *
   * @return {?boolean}
   */


  get isFriendsOnly() {
    if (!this.$filled) {
      return null;
    }

    return Boolean(this.payload.friends_only);
  }
  /**
   * Returns the date object when this post was created
   *
   * @return {?Date}
   */


  get date() {
    return this.payload.date || null;
  }
  /**
   * Returns the identifier author
   *
   * @return {?number}
   */


  get authorId() {
    return this.payload.from_id || null;
  }
  /**
   * Returns the post type
   *
   * @return {?string}
   */


  get postType() {
    return this.payload.post_type || null;
  }
  /**
   * Returns the post text
   *
   * @return {?string}
   */


  get text() {
    return this.payload.text || null;
  }
  /**
   * Returns the administrator identifier that posted the entry
   *
   * @return {?number}
   */


  get createdUserId() {
    return this.payload.created_by || null;
  }
  /**
   * The identifier of the record owner, in response to which the current
   *
   * @return {?number}
   */


  get replyOwnerId() {
    return this.payload.reply_owner_id || null;
  }
  /**
   * The identifier of the record in response to which the current one was left.
   *
   * @return {?number}
   */


  get replyPostId() {
    return this.payload.reply_post_id || null;
  }
  /**
   * Returns author identifier if the entry was published
   * on behalf of the community and signed by the user
   *
   * @return {?number}
   */


  get signerId() {
    return this.payload.signer_id || null;
  }
  /**
   * Returns the number of record views
   *
   * @return {?number}
   */


  get viewsCount() {
    if (!this.$filled) {
      return null;
    }

    return this.payload.views.count;
  }
  /**
   * Returns the geo location
   *
   * @return {?Object}
   */


  get geo() {
    return this.payload.geo || null;
  }
  /**
   * Returns the likes info
   *
   * @return {?Object}
   */


  get likes() {
    return this.payload.likes || null;
  }
  /**
   * Returns the likes count
   *
   * @return {?number}
   */


  get likesCount() {
    if (!this.$filled) {
      return null;
    }

    return this.payload.likes.count;
  }
  /**
   * Returns the reposts count
   *
   * @return {?number}
   */


  get repostsCount() {
    if (!this.$filled) {
      return null;
    }

    return this.payload.reposts.count;
  }
  /**
   * Returns the post source
   *
   * @return {?Object}
   */


  get postSource() {
    return this.payload.post_source || null;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.getType() === type);
  }

}

class LinkAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('link', payload);
    this.vk = vk;
  }
  /**
   * Returns the URL of the link
   *
   * @return {string}
   */


  get url() {
    return this.payload.url;
  }
  /**
   * Returns the title
   *
   * @return {string}
   */


  get title() {
    return this.payload.title;
  }
  /**
   * Returns the description
   *
   * @return {string}
   */


  get description() {
    return this.payload.description;
  }

}

const SMALL_SIZES = ['m', 's'];
const MEDIUM_SIZES = ['y', 'r', 'q', 'p', ...SMALL_SIZES];
const LARGE_SIZES = ['w', 'z', ...MEDIUM_SIZES];
class PhotoAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('photo', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.$filled = 'album_id' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const [photo] = await this.vk.api.photos.getById({
      photos: `${this.ownerId}_${this.id}`,
      extended: 0
    });
    this.payload = photo;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }
  /**
   * Returns the ID of the user who uploaded the image
   *
   * @return {?number}
   */


  get userId() {
    return this.payload.user_id || null;
  }
  /**
   * Returns the ID of the album
   *
   * @return {?number}
   */


  get albumId() {
    return this.payload.album_id || null;
  }
  /**
   * Returns the photo text
   *
   * @return {?string}
   */


  get text() {
    return this.payload.text || null;
  }
  /**
   * Returns the Date object when this photo was created
   *
   * @return {?Date}
   */


  get date() {
    return this.payload.date || null;
  }
  /**
   * Returns the photo height
   *
   * @return {?number}
   */


  get height() {
    return this.payload.height || null;
  }
  /**
   * Returns the photo width
   *
   * @return {?number}
   */


  get width() {
    return this.payload.width || null;
  }
  /**
   * Returns the sizes
   *
   * @return {?Object[]}
   */


  get sizes() {
    return this.payload.sizes || null;
  }
  /**
   * Returns the URL of a small photo
   * (130 or 75)
   *
   * @return {?string}
   */


  get smallPhoto() {
    if (!this.$filled) {
      return null;
    }

    const [size] = this.getSizes(SMALL_SIZES);
    return size.url;
  }
  /**
   * Returns the URL of a medium photo
   * (807 or 604 or less)
   *
   * @return {?string}
   */


  get mediumPhoto() {
    if (!this.$filled) {
      return null;
    }

    const [size] = this.getSizes(MEDIUM_SIZES);
    return size.url;
  }
  /**
   * Returns the URL of a large photo
   * (2560 or 1280 or less)
   *
   * @return {?string}
   */


  get largePhoto() {
    if (!this.$filled) {
      return null;
    }

    const [size] = this.getSizes(LARGE_SIZES);
    return size.url;
  }
  /**
   * Returns the sizes of the required types
   *
   * @param {string[]} sizeTypes
   *
   * @return {Object[]}
   */


  getSizes(sizeTypes) {
    const {
      sizes
    } = this;
    return sizeTypes.map(sizeType => sizes.find(size => size.type === sizeType) || null).filter(Boolean);
  }

}

class AudioAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('audio', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.$filled = 'duration' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const [audio] = await this.vk.api.audio.getById({
      audios: `${this.ownerId}_${this.id}`
    });
    this.payload = audio;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }
  /**
   * Checks whether audio is in high quality
   *
   * @return {?boolean}
   */


  get isHq() {
    const {
      is_hq: isHq
    } = this.payload;

    if (!isHq) {
      return null;
    }

    return isHq === 1;
  }
  /**
   * Returns the artist
   *
   * @return {?string}
   */


  get artist() {
    return this.payload.artist || null;
  }
  /**
   * Returns the title
   *
   * @return {?string}
   */


  get title() {
    return this.payload.title || null;
  }
  /**
   * Returns the duration
   *
   * @return {?number}
   */


  get duration() {
    return this.payload.duration || null;
  }
  /**
   * Returns the date object when this audio was created
   *
   * @return {?number}
   */


  get date() {
    return this.payload.date || null;
  }
  /**
   * Returns the URL of the audio
   *
   * @return {?string}
   */


  get url() {
    return this.payload.url || null;
  }
  /**
   * Returns the ID of the lyric
   *
   * @return {?number}
   */


  get lyricsId() {
    return this.payload.lyrics_id || null;
  }
  /**
   * Returns the ID of the album
   *
   * @return {?number}
   */


  get albumId() {
    return this.payload.album_id || null;
  }
  /**
   * Returns the ID of the genre
   *
   * @return {?number}
   */


  get genreId() {
    return this.payload.album_id || null;
  }

}

class VideoAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('video', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.$filled = 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const {
      items
    } = await this.vk.api.video.get({
      videos: `${this.ownerId}_${this.id}`,
      extended: 0
    });
    const [video] = items;
    this.payload = video;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }
  /**
   * Checks whether the video is repeatable
   *
   * @return {?boolean}
   */


  get isRepeat() {
    return this.checkBooleanInProperty('repeat');
  }
  /**
   * Checks that the user can add a video to himself
   *
   * @return {?boolean}
   */


  get isCanAdd() {
    return this.checkBooleanInProperty('can_add');
  }
  /**
   * Checks if the user can edit the video
   *
   * @return {?boolean}
   */


  get isCanEdit() {
    return this.checkBooleanInProperty('can_edit');
  }
  /**
   * Checks whether the video is being processed
   *
   * @return {?boolean}
   */


  get isProcessing() {
    return this.checkBooleanInProperty('processing');
  }
  /**
   * Checks whether the video is a broadcast
   *
   * @return {?boolean}
   */


  get isBroadcast() {
    return this.checkBooleanInProperty('live');
  }
  /**
   * Checks whether the video is a broadcast
   *
   * @return {?boolean}
   */


  get isUpcoming() {
    return this.checkBooleanInProperty('upcoming');
  }
  /**
   * Returns the title
   *
   * @return {?string}
   */


  get title() {
    return this.payload.title || null;
  }
  /**
   * Returns the description
   *
   * @return {?string}
   */


  get description() {
    return this.payload.description || null;
  }
  /**
   * Returns the duration
   *
   * @return {?number}
   */


  get duration() {
    return this.payload.duration || null;
  }
  /**
   * Returns the date object when this video was created
   *
   * @return {?Date}
   */


  get date() {
    return this.payload.date || null;
  }
  /**
   * Returns the date object when this video was added
   *
   * @return {?Date}
   */


  get addingDate() {
    return this.payload.adding_date || null;
  }
  /**
   * Returns the count views
   *
   * @return {?number}
   */


  get viewsCount() {
    return this.payload.views || null;
  }
  /**
   * Returns the count comments
   *
   * @return {?number}
   */


  get commentsCount() {
    return this.payload.comments || null;
  }
  /**
   * Returns the URL of the page with the player
   *
   * @return {?string}
   */


  get player() {
    return this.payload.player || null;
  }
  /**
   * Returns the name of the platform (for video recordings added from external sites)
   *
   * @return {?string}
   */


  get platformName() {
    return this.payload.platform || null;
  }
  /**
   * Checks for a boolean value in the property
   *
   * @param {string} name
   *
   * @return {?boolean}
   */


  checkBooleanInProperty(name) {
    const property = this.payload[name];

    if (typeof property !== 'number') {
      return null;
    }

    return property === 1;
  }

}

class MarketAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('market', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.$filled = 'title' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const [market] = await this.vk.api.market.getById({
      item_ids: `${this.ownerId}_${this.id}`,
      extended: 0
    });
    this.payload = market;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }

}

class StickerAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('sticker', payload);
    this.vk = vk;
  }
  /**
   * Returns the identifier sticker
   *
   * @return {number}
   */


  get id() {
    return this.payload.sticker_id;
  }
  /**
   * Returns the identifier product
   *
   * @return {number}
   */


  get productId() {
    return this.payload.product_id;
  }

}

/**
 * Types of documents
 *
 * @type {Map}
 */

const documentTypes = new Map([[1, 'text'], [2, 'archive'], [3, 'gif'], [4, 'image'], [5, 'audio'], [6, 'video'], [7, 'book'], [8, 'unknown']]);
class DocumentAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('doc', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.$filled = 'ext' in payload && 'date' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const [document] = await this.vk.api.docs.getById({
      docs: `${this.ownerId}_${this.id}`
    });
    this.payload = document;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }
  /**
   * Checks if the document is a text
   *
   * @return {?boolean}
   */


  get isText() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 1;
  }
  /**
   * Checks if the document is a archive
   *
   * @return {?boolean}
   */


  get isArchive() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 2;
  }
  /**
   * Checks if the document is a gif file
   *
   * @return {?boolean}
   */


  get isGif() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 3;
  }
  /**
   * Checks if the document is a image
   *
   * @return {?boolean}
   */


  get isImage() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 4;
  }
  /**
   * Checks if the document is a graffiti
   *
   * @return {?boolean}
   */


  get isGraffiti() {
    if (!this.$filled) {
      return null;
    }

    return this.hasPreviewProperty('graffiti');
  }
  /**
   * Checks if the document is a audio
   *
   * @return {?boolean}
   */


  get isAudio() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 5;
  }
  /**
   * Checks if the document is a voice
   *
   * @return {?boolean}
   */


  get isVoice() {
    if (!this.$filled) {
      return null;
    }

    return this.hasPreviewProperty('audio_msg');
  }
  /**
   * Checks if the document is a video
   *
   * @return {?boolean}
   */


  get isVideo() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 6;
  }
  /**
   * Checks if the document is a book
   *
   * @return {?boolean}
   */


  get isBook() {
    if (!this.$filled) {
      return null;
    }

    return this.typeId === 7;
  }
  /**
   * Returns the document title
   *
   * @return {?string}
   */


  get title() {
    return this.payload.title || null;
  }
  /**
   * Returns the date when this document was created
   *
   * @return {number}
   */


  get date() {
    return this.payload.date || null;
  }
  /**
   * Returns the type identifier (1~8)
   *
   * @return {?number}
   */


  get typeId() {
    return this.payload.type || null;
  }
  /**
   * Returns the type name
   *
   * @return {?string}
   */


  get typeName() {
    if (!this.$filled) {
      return null;
    }

    return documentTypes.get(this.typeId);
  }
  /**
   * Returns the size in bytes
   *
   * @return {?number}
   */


  get size() {
    return this.payload.size || null;
  }
  /**
   * Returns the extension
   *
   * @return {?string}
   */


  get extension() {
    return this.payload.ext || null;
  }
  /**
   * Returns the URL of the document
   *
   * @return {?string}
   */


  get url() {
    return this.payload.url || null;
  }
  /**
   * Returns the info to preview
   *
   * @return {?Object}
   */


  get preview() {
    return this.payload.preview || null;
  }
  /**
   * Checks for a property in preview
   *
   * @param {string} name
   *
   * @return {boolean}
   */


  hasPreviewProperty(name) {
    const {
      preview
    } = this;

    if (preview === null) {
      return false;
    }

    return name in preview;
  }

}

class WallReplyAttachment extends ExternalAttachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('wall_reply', payload);
    this.vk = vk;
  }

}

class MarketAlbumAttachment extends Attachment {
  /**
   * Constructor
   *
   * @param {Object} payload
   * @param {VK}     vk
   */
  constructor(payload, vk) {
    super('market_album', payload.owner_id, payload.id, payload.access_key);
    this.vk = vk;
    this.payload = payload;
    this.$filled = 'title' in payload && 'updated_time' in payload;
  }
  /**
   * Load attachment payload
   *
   * @return {Promise}
   */


  async loadAttachmentPayload() {
    if (this.$filled) {
      return;
    }

    const [album] = await this.vk.api.market.getAlbumById({
      owner_id: this.ownerId,
      album_ids: this.id
    });
    this.payload = album;

    if ('access_key' in this.payload) {
      this.accessKey = this.payload.access_key;
    }

    this.$filled = true;
  }

}

const {
  createReadStream
} = nodeFs;
const {
  randomBytes
} = nodeCrypto;
const {
  inspect: inspect$5
} = nodeUtil;
const {
  NO_FILES_TO_UPLOAD,
  EXCEEDED_MAX_FILES,
  UNSUPPORTED_SOURCE_TYPE
} = uploadErrors;
const isURL = /^https?:\/\//i;
class Upload {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Upload';
  }
  /**
   * Uploading photos to an album
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment[]>}
   */


  async photoAlbum(params) {
    const photos = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getUploadServer,
      serverParams: ['album_id', 'group_id'],
      saveFiles: this.vk.api.photos.save,
      saveParams: ['album_id', 'group_id', 'latitude', 'longitude', 'caption'],
      maxFiles: 5,
      attachmentType: 'photo'
    });
    return photos.map(photo => new PhotoAttachment(photo, this.vk));
  }
  /**
   * Uploading photos to the wall
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async wallPhoto(params) {
    const [photo] = await this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getWallUploadServer,
      serverParams: ['group_id'],
      saveFiles: this.vk.api.photos.saveWallPhoto,
      saveParams: ['user_id', 'group_id', 'latitude', 'longitude', 'caption'],
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploading the main photo of a user or community
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  ownerPhoto(params) {
    return this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getOwnerPhotoUploadServer,
      serverParams: ['owner_id'],
      saveFiles: this.vk.api.photos.saveOwnerPhoto,
      maxFiles: 1,
      attachmentType: 'photo'
    }); // {
    // 	photo_hash: 'c8d43da5e1281b7aed6bb8f0c4f3ad69',
    // 	photo_src: 'https://pp.userapi.com/c836429/v836429114/673f6/5VJB8GXtK88.jpg',
    // 	photo_src_big: 'https://pp.userapi.com/c836429/v836429114/673f7/7fGvrJ1wOx0.jpg',
    // 	photo_src_small: 'https://pp.userapi.com/c836429/v836429114/673f5/l5d1ASgyuxk.jpg',
    // 	saved: 1,
    // 	post_id: 3331
    // }
  }
  /**
   * Uploading a photo to a private message
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async messagePhoto(params) {
    const [photo] = await this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getMessagesUploadServer,
      serverParams: ['peer_id'],
      saveFiles: this.vk.api.photos.saveMessagesPhoto,
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploading the main photo for a chat
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  chatPhoto(params) {
    return this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getChatUploadServer,
      serverParams: ['chat_id', 'crop_x', 'crop_y', 'crop_width'],
      saveFiles: file => this.vk.api.messages.setChatPhoto({
        file
      }),
      maxFiles: 1,
      attachmentType: 'photo'
    }); // {
    // 	message_id: 3745390,
    // 	chat: {
    // 		id: 152,
    // 		type: 'chat',
    // 		title: '<Titile name>',
    // 		admin_id: 335447860,
    // 		users: [335447860,
    // 			140192020,
    // 			153711615,
    // 			314650825,
    // 			218747758,
    // 			155944103,
    // 			159737827,
    // 			64299368,
    // 			157534541,
    // 			153608064,
    // 			335540121,
    // 			349609849,
    // 			344184938,
    // 			341178526,
    // 			198210835,
    // 			135446999,
    // 			163850606,
    // 			123640861,
    // 			316216798,
    // 			359118107,
    // 			241235369,
    // 			160213445,
    // 			126624591,
    // 			390221395,
    // 			195624402,
    // 			94955334,
    // 			167302501,
    // 			17516523,
    // 			294583792,
    // 			294869767,
    // 			114281676,
    // 			137762280,
    // 			406076540,
    // 			410605840,
    // 			395646590,
    // 			421554042,
    // 			331599090,
    // 			342269712
    // 		],
    // 		photo_50: 'https://pp.userapi.com/c837624/v837624114/5d495/gLgv-JrVmkk.jpg',
    // 		photo_100: 'https://pp.userapi.com/c837624/v837624114/5d494/VNp61I1yuCk.jpg',
    // 		photo_200: 'https://pp.userapi.com/c837624/v837624114/5d492/lAoc_fAai2Q.jpg'
    // 	}
    // }
  }
  /**
   * Uploading a photo for a product
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async marketPhoto(params) {
    const [photo] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getMarketUploadServer,
      serverParams: ['group_id', 'main_photo', 'crop_x', 'crop_y', 'crop_width'],
      saveFiles: this.vk.api.photos.saveMarketPhoto,
      saveParams: ['group_id'],
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploads a photo for the selection of goods
   *
   * @param {Object} params
   *
   * @return {Promise<PhotoAttachment>}
   */


  async marketAlbumPhoto(params) {
    const [photo] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.photos.getMarketAlbumUploadServer,
      serverParams: ['group_id'],
      saveFiles: this.vk.api.photos.saveMarketAlbumPhoto,
      saveParams: ['group_id'],
      maxFiles: 1,
      attachmentType: 'photo'
    });
    return new PhotoAttachment(photo, this.vk);
  }
  /**
   * Uploads audio
   *
   * @param {Object} params
   *
   * @return {Promise<AudioAttachment>}
   */


  async audio(params) {
    const audio = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.audio.getUploadServer,
      saveFiles: this.vk.api.audio.save,
      saveParams: ['title', 'artist'],
      maxFiles: 1,
      attachmentType: 'audio'
    });
    return new AudioAttachment(audio, this.vk);
  }
  /**
   * Uploads video
   *
   * @param {Object} params
   *
   * @return {Promise<VideoAttachment>}
   */


  async video(params) {
    /* FIXME: 400 Bad Request */
    const save = await this.vk.api.video.save(copyParams(params, ['group_id', 'album_id', 'name', 'description', 'link', 'is_private', 'wallpost', 'privacy_view', 'privacy_comment', 'no_comments', 'repeat']));
    save.id = save.video_id;

    if ('link' in params) {
      const response = await fetch(save.upload_url, {
        agent: this.vk.options.agent
      });
      await response.json();
      return new VideoAttachment(save, this.vk);
    }

    if (!Array.isArray(params.source)) {
      params.source = [params.source];
    }

    const formData = await this.buildPayload({
      maxFiles: 1,
      field: 'video_file',
      attachmentType: 'video',
      sources: params.source
    });
    const video = await this.upload(save.upload_url, formData);
    return new VideoAttachment(_objectSpread({}, save, video), this.vk);
  }
  /**
   * Uploads document
   *
   * @param {Object} params
   * @param {Object} options
   *
   * @return {Promise<DocumentAttachment>}
   */


  async document(params, {
    attachmentType = null
  } = {}) {
    const [document] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.docs.getUploadServer,
      serverParams: ['type', 'group_id'],
      saveFiles: this.vk.api.docs.save,
      saveParams: ['title', 'tags'],
      maxFiles: 1,
      attachmentType: attachmentType || 'doc'
    });
    return new DocumentAttachment(document, this.vk);
  }
  /**
   * Uploads wall document
   *
   * @param {Object} params
   * @param {Object} options
   *
   * @return {Promise<DocumentAttachment>}
   */


  async wallDocument(params, {
    attachmentType = null
  } = {}) {
    const [document] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.docs.getWallUploadServer,
      serverParams: ['type', 'group_id'],
      saveFiles: this.vk.api.docs.save,
      saveParams: ['title', 'tags'],
      maxFiles: 1,
      attachmentType: attachmentType || 'doc'
    });
    return new DocumentAttachment(document, this.vk);
  }
  /**
   * Uploads message document
   *
   * @param {Object} params
   * @param {Object} options
   *
   * @return {Promise<DocumentAttachment>}
   */


  async messageDocument(params, {
    attachmentType = null
  } = {}) {
    const [document] = await this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.docs.getMessagesUploadServer,
      serverParams: ['type', 'peer_id'],
      saveFiles: this.vk.api.docs.save,
      saveParams: ['title', 'tags'],
      maxFiles: 1,
      attachmentType: attachmentType || 'doc'
    });
    return new DocumentAttachment(document, this.vk);
  }
  /**
   * Uploads audio message
   *
   * @param {Object} params
   *
   * @return {Promise<DocumentAttachment>}
   */


  voice(params) {
    params.type = 'audio_message';
    return this.messageDocument(params, {
      attachmentType: 'voice'
    }); // [{
    // 	id: 450654090,
    // 	owner_id: 195624402,
    // 	title: 'file0.dat',
    // 	size: 6893689,
    // 	ext: 'ogg',
    // 	url: 'https://vk.com/doc195624402_450654090?hash=4885f0597af540ea3c&dl=GE4TKNRSGQ2DAMQ:1505453671:d23a533d7c485e7426&api=1&no_preview=1',
    // 	date: 1505453671,
    // 	type: 5,
    // 	preview: {
    // 		audio_msg: {
    // 			duration: 243,
    // 			waveform: [5,
    // 				6,
    // 				5,
    // 				5,
    // 				4,
    // 				3,
    // 				4,
    // 				2,
    // 				4,
    // 				3,
    // 				4,
    // 				4,
    // 				3,
    // 				2,
    // 				1,
    // 				1,
    // 				2,
    // 				3,
    // 				4,
    // 				4,
    // 				6,
    // 				8,
    // 				13,
    // 				13,
    // 				11,
    // 				6,
    // 				5,
    // 				4,
    // 				3,
    // 				3,
    // 				1,
    // 				2,
    // 				1,
    // 				2,
    // 				1,
    // 				4,
    // 				8,
    // 				10,
    // 				12,
    // 				10,
    // 				13,
    // 				12,
    // 				14,
    // 				16,
    // 				16,
    // 				17,
    // 				11,
    // 				9,
    // 				8,
    // 				9,
    // 				10,
    // 				10,
    // 				7,
    // 				1,
    // 				3,
    // 				1,
    // 				2,
    // 				5,
    // 				8,
    // 				10,
    // 				10,
    // 				11,
    // 				13,
    // 				14,
    // 				18,
    // 				19,
    // 				20,
    // 				22,
    // 				20,
    // 				22,
    // 				24,
    // 				25,
    // 				27,
    // 				25,
    // 				21,
    // 				20,
    // 				18,
    // 				15,
    // 				12,
    // 				6,
    // 				3,
    // 				4,
    // 				6,
    // 				10,
    // 				13,
    // 				10,
    // 				9,
    // 				8,
    // 				5,
    // 				3,
    // 				2,
    // 				3,
    // 				8,
    // 				11,
    // 				10,
    // 				2,
    // 				2,
    // 				9,
    // 				12,
    // 				19,
    // 				...23 more items
    // 			],
    // 			link_ogg: 'https://cs540101.userapi.com/c807320/u195624402/audio/440482857b.ogg',
    // 			link_mp3: 'https://cs540101.userapi.com/c807320/u195624402/audio/440482857b.mp3'
    // 		}
    // 	}
    // }]
  }
  /**
   * Uploads graffiti
   *
   * @param {Object} params
   *
   * @return {Promise<DocumentAttachment>}
   */


  graffiti(params) {
    params.type = 'graffiti';
    return this.document(params, {
      attachmentType: 'graffiti'
    });
  }
  /**
   * Uploads community cover
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  groupCover(params) {
    return this.conduct({
      field: 'photo',
      params,
      getServer: this.vk.api.photos.getOwnerCoverPhotoUploadServer,
      serverParams: ['group_id', 'crop_x', 'crop_y', 'crop_x2', 'crop_y2'],
      saveFiles: this.vk.api.photos.saveOwnerCoverPhoto,
      maxFiles: 1,
      attachmentType: 'photo'
    }); // {
    // 	images: [
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46404/r-1Nhr-Dktc.jpg',
    // 			width: 200,
    // 			height: 50
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46403/oDB9tAgtUrQ.jpg',
    // 			width: 400,
    // 			height: 101
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46400/gLwCTmDEPXY.jpg',
    // 			width: 795,
    // 			height: 200
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46402/w2ucyq8zwF8.jpg',
    // 			width: 1080,
    // 			height: 272
    // 		},
    // 		{
    // 			url: 'https://cs7056.userapi.com/c639526/v639526192/46401/YTmN89yMaU0.jpg',
    // 			width: 1590,
    // 			height: 400
    // 		}
    // 	]
    // }
  }
  /**
   * Uploads photo stories
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  storiesPhoto(params) {
    return this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.stories.getPhotoUploadServer,
      serverParams: ['add_to_news', 'user_ids', 'reply_to_story', 'link_text', 'link_url', 'group_id'],
      saveFiles: save => save,
      maxFiles: 1,
      attachmentType: 'photo'
    });
  }
  /**
   * Uploads video stories
   *
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  storiesVideo(params) {
    return this.conduct({
      field: 'file',
      params,
      getServer: this.vk.api.stories.getVideoUploadServer,
      serverParams: ['add_to_news', 'user_ids', 'reply_to_story', 'link_text', 'link_url', 'group_id'],
      saveFiles: save => save,
      maxFiles: 1,
      attachmentType: 'video'
    });
  }
  /**
   * Behavior for the upload method
   *
   * @param {Object} conduct
   * @property [field]          Field name
   * @property [params]         Upload params
   *
   * @property [getServer]      Get server functions
   * @property [serverParams]   Copies server params
   *
   * @property [saveFiles]      Save files functions
   * @property [saveParams]     Copies save params
   *
   * @property [maxFiles]       Max uploaded files for one request
   * @property [attachmentType] Attachment type
   *
   * @return {Promise<Object>}
   */


  async conduct({
    field,
    params,
    getServer,
    serverParams = [],
    saveFiles,
    saveParams = [],
    maxFiles = 1,
    attachmentType
  }) {
    if (!Array.isArray(params.source)) {
      params.source = [params.source];
    }

    params.source = params.source.filter(Boolean);

    if (params.source.length === 0) {
      throw new UploadError({
        message: 'No files to upload',
        code: NO_FILES_TO_UPLOAD
      });
    }

    if (params.source.length > maxFiles) {
      throw new UploadError({
        message: 'The number of files uploaded has exceeded',
        code: EXCEEDED_MAX_FILES
      });
    }

    if ('uploadUrl' in params) {
      getServer = () => ({
        upload_url: params.uploadUrl
      });
    }

    const [{
      upload_url: url
    }, formData] = await Promise.all([getServer(copyParams(params, serverParams)), this.buildPayload({
      field,
      maxFiles,
      attachmentType,
      sources: params.source
    })]);
    const uploaded = await this.upload(url, formData, params);

    if (typeof uploaded !== 'object') {
      return await saveFiles(uploaded);
    }

    return await saveFiles(_objectSpread({}, copyParams(params, saveParams), uploaded));
  }
  /**
   * Building form data
   *
   * @param {Object} payload
   *
   * @return {Promise}
   */


  async buildPayload({
    field,
    sources,
    maxFiles,
    attachmentType
  }) {
    const boundary = randomBytes(32).toString('hex');
    const formData = new MultipartStream(boundary);
    const isMultipart = maxFiles > 1;
    const tasks = sources.map(source => {
      if (typeof source === 'object' && 'value' in source) {
        return source;
      }

      return {
        value: source
      };
    }).map(async ({
      value,
      filename,
      contentType = null
    }, i) => {
      if (typeof value === 'string') {
        if (isURL.test(value)) {
          const response = await fetch(value);
          value = response.body;
        } else {
          value = createReadStream(value);
        }
      }

      if (!filename) {
        filename = `file${i}.${defaultExtensions[attachmentType] || 'dat'}`;
      }

      if (isStream(value) || Buffer.isBuffer(value)) {
        const name = isMultipart ? field + (i + 1) : field;
        const headers = {};

        if (contentType !== null) {
          headers['Content-Type'] = contentType;
        } else if (attachmentType in defaultContentTypes) {
          headers['Content-Type'] = defaultContentTypes[attachmentType];
        }

        return formData.append(name, value, {
          filename,
          headers
        });
      }

      throw new UploadError({
        message: 'Unsupported source type',
        code: UNSUPPORTED_SOURCE_TYPE
      });
    });
    await Promise.all(tasks);
    return formData;
  }
  /**
   * Upload form data
   *
   * @param {URL|string}      url
   * @param {MultipartStream} formData
   * @param {Object}          options
   *
   * @return {Promise<Object>}
   */


  async upload(url, formData, {
    timeout
  } = {}) {
    const {
      agent,
      uploadTimeout
    } = this.vk.options;
    let response = await fetch(url, {
      agent,
      compress: false,
      method: 'POST',
      timeout: timeout || uploadTimeout,
      headers: {
        Connection: 'keep-alive',
        'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`
      },
      body: formData
    });

    if (response.status !== 200) {
      throw new Error(response.statusText);
    }

    response = await response.json();

    if ('response' in response) {
      return response.response;
    }

    return response;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$5.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} {}`;
  }

}

const unespaceOffset = /"offset":"(\w+)"/g;
var getExecuteCode = (({
  method,
  params,
  parallelCount
}) => {
  const methodCode = getExecuteMethod(method, _objectSpread({}, params, {
    offset: 'offset'
  }));
  const code = `
		var total = parseInt(Args.total);
		var offset = parseInt(Args.offset);
		var received = parseInt(Args.received);

		var proceed = total == 0 || received < total;

		var i = 0, items = [], result, length;

		while (i < ${parallelCount} && proceed) {
			result = ${methodCode};
			length = result.items.length;

			if (total == 0 || total > result.count) {
				total = result.count;
			}

			items = items + result.items;

			offset = offset + length;
			received = received + length;

			proceed = received < total;
			i = i + 1;
		}

		return {
			total: total,
			items: items.splice(0, total)
		};
	`;
  return code.replace(unespaceOffset, '"offset":$1');
});

const {
  inspect: inspect$6
} = nodeUtil;
const {
  Readable
} = nodeStream;
const debug$7 = createDebug('vk-io:collect:stream');
const {
  APP_TOKEN_NOT_VALID,
  RESPONSE_SIZE_TOO_BIG
} = apiErrors;
const {
  EXECUTE_ERROR
} = collectErrors;
class CollectStream extends Readable {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk, {
    options,
    method,
    limit,
    max = null
  }) {
    super({
      objectMode: true
    });
    this.vk = vk;

    const {
      parallelCount = 25,
      count = null,
      offset = 0
    } = options,
          params = _objectWithoutProperties(options, ["parallelCount", "count", "offset"]);

    this.method = method;
    this.params = _objectSpread({}, params, {
      count: limit
    });

    if (parallelCount < 1 || parallelCount > 25) {
      throw new RangeError('The number of parallel calls can be between 1 and 25');
    }

    this.parallelCount = parallelCount;
    const hasMax = max !== null;
    const hasCount = count !== null;

    if (hasCount && hasMax && count > max || hasMax && !hasCount) {
      this.total = max;
    } else {
      this.total = count;
    }

    this.offset = offset;
    this.skipOffset = offset;
    this.received = 0;
    this.attempts = 0;
    this.promise = null;
    this.supportExecute = true;
    this.code = getExecuteCode({
      params: this.params,
      parallelCount,
      method
    });
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'CollectStream';
  }
  /**
   * Promise based
   *
   * @param {Function} thenFn
   * @param {Function} catchFn
   *
   * @return {Promise<Object>}
   */


  then(thenFn, catchFn) {
    if (this.promise === null) {
      let collect = [];
      this.promise = new Promise((resolve, reject) => {
        this.on('error', reject).on('end', () => resolve(collect)).on('data', ({
          items
        }) => {
          collect = [...collect, ...items];
        });
      });
    }

    return Promise.resolve(this.promise).then(thenFn, catchFn);
  }
  /**
   * Fetch data
   *
   * @return {Promise}
   */


  async _read() {
    const isNotFirst = this.total !== null && this.received !== 0;

    if (isNotFirst && this.total - this.skipOffset <= this.received) {
      this.push(null);
      return;
    }

    let items;

    if (!this.supportExecute || this.parallelCount === 1) {
      const request = new Request(this.method, _objectSpread({}, this.params, {
        offset: this.offset
      }));
      let result;

      try {
        result = await this.vk.api.callWithRequest(request);
      } catch (error) {
        const {
          collectAttempts
        } = this.vk.options;

        if (this.attempts >= collectAttempts) {
          this.emit('error', error);
          return;
        }

        this.attempts += 1; // eslint-disable-next-line no-underscore-dangle

        this._read();

        return;
      }

      const {
        count,
        items: collect
      } = result;

      if (this.total === null || this.total > count) {
        this.total = count;
      }

      items = collect;
    } else {
      let result;

      try {
        result = await this.vk.api.execute({
          code: this.code,
          total: this.total,
          offset: this.offset,
          received: this.received
        });
      } catch (error) {
        if (error.code === APP_TOKEN_NOT_VALID) {
          this.supportExecute = false;
          debug$7('execute not supported in token'); // eslint-disable-next-line no-underscore-dangle

          this._read();

          return;
        }

        if (error.code === RESPONSE_SIZE_TOO_BIG) {
          this.parallelCount -= 1;
          this.code = getExecuteCode({
            parallelCount: this.parallelCount,
            params: this.params,
            method: this.method
          }); // eslint-disable-next-line no-underscore-dangle

          this._read();

          return;
        }

        const {
          collectAttempts
        } = this.vk.options;

        if (this.attempts >= collectAttempts) {
          this.emit('error', error);
          return;
        }

        this.attempts += 1; // eslint-disable-next-line no-underscore-dangle

        this._read();

        return;
      }

      const {
        response,
        errors
      } = result;

      if (errors.length > 0) {
        this.emit('error', new CollectError({
          message: 'Execute error',
          code: EXECUTE_ERROR,
          errors
        }));
        return;
      }

      const {
        total,
        items: collect
      } = response;
      this.total = total;
      items = collect;
    }

    const {
      length
    } = items;

    if (length === 0) {
      this.push(null);
      return;
    }

    this.offset += length;
    this.received += length;
    const {
      total,
      received
    } = this;
    let percent = Math.round(received / total * 100);

    if (Number.isNaN(percent)) {
      percent = 100;
    }

    this.push({
      received,
      percent,
      total,
      items
    });
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$6.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      total,
      offset,
      received
    } = this;
    const payload = {
      total,
      offset,
      received
    };
    return `${options.stylize(name, 'special')} ${inspect$6(payload, options)}`;
  }

}

/**
 * List limits VK
 * Last updated 09.10.2017
 *
 * @type {Array}
 */
var LIMITS_METHODS = [
/**
 * Account
 */
['account.getActiveOffers', 100], ['account.getBanned', 200],
/**
 * Ads
 */
['ads.getAds', 100, 2000], ['ads.getAdsLayout', 100, 2000], ['ads.getAdsTargeting', 100, 2000],
/**
 * Apps
 */
['apps.getCatalog', 100], ['apps.getFriendsList', 5000],
/**
 * Audio
 */
['audio.get', 6000], ['audio.search', 300, 1000], ['audio.getAlbums', 100], ['audio.getRecommendations', 1000], ['audio.getPopular', 1000],
/**
 * Board
 */
['board.getComments', 100], ['board.getTopics', 100],
/**
 * Database
 */
['database.getChairs', 10000], ['database.getCities', 1000], ['database.getCountries', 1000], ['database.getFaculties', 10000], ['database.getRegions', 1000], ['database.getSchools', 10000], ['database.getUniversities', 10000],
/**
 * Docs
 */
['docs.get', 2000, 2000], ['docs.search', 1000, 1000],
/**
 * Fave
 */
['fave.getLinks', 100], ['fave.getMarketItems', 100], ['fave.getPhotos', 100], ['fave.getUsers', 100], ['fave.getVideos', 100],
/**
 * Friends
 */
['friends.get', 1000], ['friends.getMutual', 1000], ['friends.getMutual', 1000], ['friends.getOnline', 1000], ['friends.getRecent', 1000], ['friends.getRequests', 1000], ['friends.getSuggestions', 500], ['friends.search', 1000],
/**
 * Gifts
 */
['gifts.get', 100],
/**
 * Groups
 */
['groups.get', 1000], ['groups.getBanned', 200], ['groups.getInvitedUsers', 100], ['groups.getInvites', 100], ['groups.getMembers', 1000], ['groups.getRequests', 200],
/**
 * Leads
 */
['leads.getUsers', 1000],
/**
 * Likes
 */
['likes.getList', 100],
/**
 * Market
 */
['market.get', 200], ['market.getAlbums', 100], ['market.getCategories', 1000], ['market.getComments', 100], ['market.search', 200],
/**
 * messages
 */
['messages.get', 200], ['messages.getDialogs', 200], ['messages.getHistory', 200], ['messages.search', 100],
/**
 * Notes
 */
['notes.get', 100], ['notes.getComments', 100],
/**
 * Orders
 */
['orders.get', 1000],
/**
 * Photos
 */
['photos.get', 1000], ['photos.getAlbums', 100], ['photos.getAll', 200], ['photos.getAllComments', 100], ['photos.getComments', 100], ['photos.getNewTags', 100], ['photos.getUserPhotos', 1000], ['photos.search', 1000],
/**
 * Places
 */
['places.getCheckins', 100], ['places.search', 1000],
/**
 * Polls
 */
['polls.getVoters', 100],
/**
 * Storage
 */
['storage.getKeys', 1000],
/**
 * Users
 */
['users.getFollowers', 1000], ['users.getSubscriptions', 200], ['users.search', 1000, 1000],
/**
 * Utils
 */
['utils.getLastShortenedLinks', 50],
/**
 * Video
 */
['video.get', 200], ['video.getAlbums', 100], ['video.getComments', 100], ['video.search', 1000, 1000],
/**
 * Wall
 */
['wall.get', 100], ['wall.getComments', 100], ['wall.getReposts', 1000], ['wall.search', 100],
/**
 * Widgets
 */
['widgets.getComments', 200], ['widgets.getPages', 200]];

const {
  inspect: inspect$7
} = nodeUtil;
class Chain {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.queue = [];
    this.started = false;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Chain';
  }
  /**
   * Adds method to queue
   *
   * @param {string} method
   * @param {Object} params
   *
   * @return {Promise<mixed>}
   */


  append(method, params) {
    if (this.started) {
      throw new Error('Chain already started');
    }

    const request = new Request(method, params);
    this.queue.push(request);
    return request.promise;
  }
  /**
   * Promise based
   *
   * @param {Function} thenFn
   * @param {Function} catchFn
   *
   * @return {Promise<Object>}
   */


  then(thenFn, catchFn) {
    return Promise.resolve(this.run()).then(thenFn, catchFn);
  }
  /**
   * Starts the chain
   *
   * @return {Promise}
   */


  async run() {
    if (this.started) {
      throw new Error('Chain already started');
    }

    this.started = true;
    const {
      queue
    } = this;

    if (queue.length === 0) {
      return [];
    }

    let out = {
      response: [],
      errors: []
    };

    while (queue.length > 0) {
      const tasks = queue.splice(0, 25);
      const code = getChainReturn(tasks.map(String));

      try {
        const response = await this.vk.api.execute({
          code
        });
        resolveExecuteTask(tasks, response);
        out = {
          response: [...out.response, ...response.response],
          errors: [...out.errors, ...response.errors]
        };
      } catch (error) {
        for (const task of tasks) {
          task.reject(error);
        }

        throw error;
      }
    }

    return out;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$7.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      queue
    } = this;
    const payload = {
      started,
      queue
    };
    return `${options.stylize(name, 'special')} ${inspect$7(payload, options)}`;
  }

}

const {
  inspect: inspect$8
} = nodeUtil;
class Collect {
  /**
   * constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;

    for (const [method, limit, max] of LIMITS_METHODS) {
      const [group, name] = method.split('.');

      if (!(group in this)) {
        this[group] = {};
      }

      this[group][name] = (options = {}) => new CollectStream(this.vk, {
        options,
        method,
        limit,
        max
      });
    }
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Collect';
  }
  /**
   * Returns new Chain instance
   *
   * @return {Chain}
   */


  chain() {
    return new Chain(this.vk);
  }
  /**
   * Call multiple executors
   *
   * @param {string} method
   * @param {Array}  queue
   *
   * @return {Promise<Array>}
   */


  async executes(method, queue) {
    queue = queue.map(params => getExecuteMethod(method, params));
    const promises = [];

    while (queue.length !== 0) {
      const code = getChainReturn(queue.splice(0, 25));
      promises.push(this.vk.api.execute({
        code
      }));
    }

    let out = {
      response: [],
      errors: []
    };

    for (const _ref of await Promise.all(promises)) {
      const {
        response,
        errors
      } = _ref;
      out = {
        response: [...out.response, ...response],
        errors: [...out.errors, ...errors]
      };
    }

    return out;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$8.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} {}`;
  }

}

const {
  inspect: inspect$9
} = nodeUtil;
/**
 * Middleware stack
 *
 * @public
 */

class Middleware {
  /**
   * Constructor
   *
   * @param {Array} middlewares
   */
  constructor(...middlewares) {
    this.stack = [];
    this.use(middlewares);
  }
  /**
   * Adds middlewares
   *
   * @param {Array} middlewares
   *
   * @return {this}
   */


  use(...middlewares) {
    for (const middleware of middlewares) {
      if (Array.isArray(middleware)) {
        this.use(...middleware);
        continue;
      }

      if (typeof middleware !== 'function') {
        throw new TypeError('Middleware must be composed of functions!');
      }

      this.stack.push(middleware);
    }

    return this;
  }
  /**
   * Launches the middleware chain
   *
   * @param {Array} args
   *
   * @return {Promise<boolean>}
   */


  run(...args) {
    const {
      stack
    } = this;
    let index = -1;
    const status = {
      finished: true,
      contexts: args
    };

    const next = async i => {
      if (i <= index) {
        throw new Error('next() called multiple times');
      }

      index = i;
      const middleware = stack[i];

      if (!middleware) {
        status.finished = true;
        return status;
      }

      await middleware(...args, () => next(i + 1));
      status.finished = stack.length <= index;
      return status;
    };

    return next(0);
  }
  /**
   * Custom inspect object
   *
   * @param {?Number} depth
   * @param {Object}  options
   *
   * @return {String}
   */


  [inspect$9.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} { ${inspect$9(this.stack, options)} }`;
  }

}

const {
  inspect: inspect$a
} = nodeUtil;
class Context {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.type = null;
    this.subTypes = [];
    this.state = {};
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Checks whether the context of some of these types
   *
   * @param {string[]} types
   *
   * @return {boolean}
   */


  is(types) {
    if (!Array.isArray(types)) {
      types = [types];
    }

    return [this.type, ...this.subTypes].some(type => types.includes(type));
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$a.custom](depth, options) {
    const {
      name
    } = this.constructor;
    return `${options.stylize(name, 'special')} ${inspect$a(_objectSpread({}, this, {
      vk: '<VK>'
    }), options)}`;
  }

}

class VoteContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    this.type = 'vote';
    this.subTypes = ['pull_vote'];
  }
  /**
   * Returns the identifier poll
   *
   * @return {number}
   */


  get id() {
    return this.payload.poll_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  get userId() {
    return this.payload.user_id;
  }
  /**
   * Returns the identifier owner
   *
   * @return {number}
   */


  get ownerId() {
    return this.payload.owner_id;
  }
  /**
   * Returns the identifier option
   *
   * @return {number}
   */


  get optionId() {
    return this.payload.option_id;
  }

}

class TypingContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, userId, extra]) {
    super(vk);
    const isChat = eventId === 62;
    this.payload = {
      user_id: userId,
      chat_id: isChat ? extra : null,
      peer_id: isChat ? extra + CHAT_PEER : userId
    };
    this.type = 'typing';
    this.subTypes = [eventId === 61 ? 'typing_user' : 'typing_chat'];
  }
  /**
   * Checks that the message is typed in the dm
   *
   * @return {boolean}
   */


  get isUser() {
    return this.subTypes.includes('typing_user');
  }
  /**
   * Checks that the message is typed in the chat
   *
   * @return {boolean}
   */


  get isChat() {
    return this.subTypes.includes('typing_chat');
  }
  /**
   * Returns the identifier peer
   *
   * @return {number}
   */


  get peerId() {
    return this.payload.peer_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  get userId() {
    return this.payload.user_id;
  }
  /**
   * Returns the identifier chat
   *
   * @return {?number}
   */


  get chatId() {
    return this.payload.chat_id;
  }

}

/**
 * Special attachments in one message
 *
 * @type {Object}
 */
const specialAttachments = {
  sticker: raw => ({
    type: 'sticker',
    sticker: {
      sticker_id: Number(raw.attach1),
      product_id: Number(raw.attach1_product_id)
    }
  }),
  money_transfer: raw => ({
    type: 'money_transfer',
    money_transfer: {
      data: raw.attach1,
      amount: Number(raw.attach1_amount),
      currency: Number(raw.attach1_currency)
    }
  }),
  gift: raw => ({
    type: 'gift',
    gift: {
      id: Number(raw.attach1)
    }
  })
};
/**
 * Transform message to Object
 *
 * @param {Array} update
 *
 * @return {Object}
 */

function transformMessage([, id, flags, peer, date, text, extra, attachments]) {
  const message = {
    id,
    date,
    text,
    flags,
    geo: 'geo' in attachments ? {} : null,
    random_id: extra.random_id || null,
    out: Number((flags & 2) === 2),
    payload: extra.payload ? extra.payload : null
  };

  if (peer < 0) {
    message.out = Number((flags & 2) === 0);
    message.important = (flags & 1) !== 0;
  } else {
    message.out = Number((flags & 2) !== 0);
    message.important = (flags & 8) !== 0;
  }

  message.peer_id = peer;
  message.from_id = peer;

  if ('from' in extra) {
    message.from_id = Number(extra.from);
  }

  if ('source_act' in extra) {
    message.action = {
      type: extra.source_act,
      text: extra.source_text,
      member_id: extra.source_mid
    };
  }

  if (attachments.attach1_type in specialAttachments) {
    message.attachments = [specialAttachments[attachments.attach1_type](attachments)];
  } else {
    message.attachments = [];

    for (let i = 1, key = 'attach1'; key in attachments; i += 1, key = `attach${i}`) {
      const type = attachments[`${key}_type`];

      if (type === 'link') {
        const attachment = {
          type: 'link',
          link: {
            url: attachments[`${key}_url`],
            title: attachments[`${key}_title`],
            description: attachments[`${key}_desc`]
          }
        };
        const photoKey = `${key}_photo`;

        if (attachments[photoKey]) {
          const [owner, attachmentId] = attachments[photoKey].split('_');
          attachment.link.photo = {
            id: Number(attachmentId),
            owner_id: Number(owner)
          };
        }

        message.attachments.push(attachment);
        continue;
      }

      const [owner, attachmentId] = attachments[key].split('_');
      const attachment = {
        type,
        [type]: {
          id: Number(attachmentId),
          owner_id: Number(owner)
        }
      };
      const kindKey = `${key}_kind`;

      if (type === 'doc' && kindKey in attachments) {
        attachment[type].kind = attachments[kindKey];
      }

      message.attachments.push(attachment);
    }
  }

  let {
    fwd = null
  } = attachments; // Now long poll receive such forward messages 0_0,0_0

  if (fwd !== null) {
    const indexColon = fwd.indexOf(':');

    if (indexColon !== -1) {
      fwd = fwd.substring(0, indexColon);
    }

    message.fwd_messages = fwd.split(',').map(attachment => {
      const [owner] = attachment.split('_');
      return {
        from_id: Number(owner),
        fwd_messages: []
      };
    });
  }

  return message;
}

/**
 * Returns peer id type
 *
 * @param {number} id
 *
 * @return {string}
 */

const getPeerType = id => {
  if (CHAT_PEER < id) {
    return messageSources.CHAT;
  }

  if (id < 0) {
    return messageSources.GROUP;
  }

  return messageSources.USER;
};

class MessageContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    source,
    updateType,
    groupId = null
  }) {
    super(vk);
    const isPolling = source === updatesSources.POLLING;
    const isWebhook = source === updatesSources.WEBHOOK;

    if (isPolling) {
      payload = transformMessage(payload);
    }

    if (!payload.action) {
      payload.action = {};
    }

    this.payload = payload;
    this.$filled = isWebhook;
    this.$groupId = groupId;
    const {
      peer_id: peerId,
      from_id: fromId
    } = payload;
    this.$from = {
      id: peerId,
      type: getPeerType(peerId)
    };
    this.$sender = {
      id: fromId,
      type: getPeerType(fromId)
    };
    this.text = this.payload.text ? unescapeHTML(this.payload.text) : null;
    this.attachments = transformAttachments(payload.attachments, vk);
    const subTypes = uniqueKeys(this.attachments.map(attachment => attachment.type));

    if (!this.isEvent) {
      if (isWebhook) {
        subTypes.push(updateType === 'message_edit' ? 'edit_message' : 'new_message');
      } else if (isPolling) {
        subTypes.push(updateType === 5 ? 'edit_message' : 'new_message');
      }
    } else {
      subTypes.push(this.eventType);
    }

    if (this.hasText) {
      subTypes.push('text');
    }

    this.type = 'message';
    this.subTypes = subTypes;
  }
  /**
   * Load message payload
   *
   * @return {Promise}
   */


  async loadMessagePayload() {
    if (this.$filled) {
      return;
    }

    const {
      items
    } = await this.vk.api.messages.getById({
      message_ids: this.id
    });
    const [message] = items;
    this.payload = message;
    this.attachments = transformAttachments(message.attachments, this.vk);
    this.$filled = true;
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.type === type);
  }
  /**
   * Checks if there is text
   *
   * @return {boolean}
   */


  get hasText() {
    return this.text !== null;
  }
  /**
   * Checks for forwarded messages
   *
   * @return {boolean}
   */


  get hasForwards() {
    return 'fwd_messages' in this.payload;
  }
  /**
   * Checks if there is text
   *
   * @return {boolean}
   */


  get hasGeo() {
    return Boolean(this.payload.geo);
  }
  /**
   * Check is a user
   *
   * @return {boolean}
   */


  get isUser() {
    return this.peerType === messageSources.USER;
  }
  /**
   * Checks is a chat
   *
   * @return {boolean}
   */


  get isChat() {
    return this.peerType === messageSources.CHAT;
  }
  /**
   * Checks is a group
   *
   * @return {boolean}
   */


  get isGroup() {
    return this.peerType === messageSources.GROUP;
  }
  /**
   * Check is special event
   *
   * @return {boolean}
   */


  get isEvent() {
    return this.eventType !== null;
  }
  /**
   * Checks whether the message is outbox
   *
   * @return {boolean}
   */


  get isOutbox() {
    return Boolean(this.payload.out);
  }
  /**
   * Checks whether the message is inbox
   *
   * @return {boolean}
   */


  get isInbox() {
    return !this.isOutbox;
  }
  /**
   * Checks that the message is important
   *
   * @return {boolean}
   */


  get isImportant() {
    return this.payload.important;
  }
  /**
   * Returns the identifier message
   *
   * @return {number}
   */


  get id() {
    const {
      id
    } = this.payload;
    return id !== 0 ? id : this.conversationMessageId;
  }
  /**
   * Returns the conversation message id
   *
   * @return {number}
   */


  get conversationMessageId() {
    return this.payload.conversation_message_id;
  }
  /**
   * Returns the destination identifier
   *
   * @return {number}
   */


  get peerId() {
    return this.$from.id;
  }
  /**
   * Returns the peer type
   *
   * @return {string}
   */


  get peerType() {
    return this.$from.type;
  }
  /**
   * Returns the sender identifier
   *
   * @return {number}
   */


  get senderId() {
    return this.$sender.id;
  }
  /**
   * Returns the sender type
   *
   * @return {string}
   */


  get senderType() {
    return this.$sender.type;
  }
  /**
   * Returns the identifier chat
   *
   * @return {?number}
   */


  get chatId() {
    if (!this.isChat) {
      return null;
    }

    return this.peerId - CHAT_PEER;
  }
  /**
   * Returns the date when this message was created
   *
   * @return {number}
   */


  get date() {
    return this.payload.date;
  }
  /**
   * Returns the forwards messages
   *
   * @return {Object[]}
   */


  get forwards() {
    return this.payload.fwd_messages || [];
  }
  /**
   * Returns geo
   *
   * @return {?Object}
   */


  get geo() {
    if (!this.hasGeo) {
      return null;
    }

    if (!this.$filled) {
      throw new Error('The message payload is not fully loaded');
    }

    return this.payload.geo;
  }
  /**
   * Returns the event name
   *
   * @return {?string}
   */


  get eventType() {
    const {
      type
    } = this.payload.action;

    if (!type) {
      return null;
    }

    return type;
  }
  /**
   * Returns the event member id
   *
   * @return {?number}
   */


  get eventMemberId() {
    const {
      member_id: id
    } = this.payload.action;

    if (!id) {
      return null;
    }

    return Number(id);
  }
  /**
   * Returns the event name
   *
   * @return {?string}
   */


  get eventText() {
    const {
      text
    } = this.payload.action;

    if (!text) {
      return null;
    }

    return text;
  }
  /**
   * Returns the event email
   *
   * @return {?string}
   */


  get eventEmail() {
    const {
      email
    } = this.payload.action;

    if (!email) {
      return null;
    }

    return email;
  }
  /**
   * Returns the message payload
   *
   * @return {?mixed}
   */


  get messagePayload() {
    const {
      payload = null
    } = this.payload;

    if (payload === null) {
      return null;
    }

    return JSON.parse(payload);
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.type === type);
  }
  /**
   * Gets a link to invite the user to a conversation
   *
   * @param {Object} params
   *
   * @type {Promise<Object>}
   */


  getInviteLink(params = {}) {
    return this.vk.api.messages.getInviteLink(_objectSpread({}, params, {
      peer_id: this.peerId
    }));
  }
  /**
   * Edits a message
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  editMessage(params) {
    return this.vk.api.messages.edit(_objectSpread({}, params, {
      peer_id: this.peerId,
      message_id: this.id
    }));
  }
  /**
   * Edits a message text
   *
   * @param {string} message
   *
   * @return {Promise}
   */


  async editMessageText(message) {
    const response = await this.editMessage({
      message
    });
    this.text = message;
    return response;
  }
  /**
   * Sends a message to the current dialog
   *
   * @param {string|Object} text
   * @param {Object}        params
   *
   * @return {Promise}
   */


  send(text, params = {}) {
    if (typeof text !== 'object') {
      params.message = text;
    } else {
      params = text;
    }

    params.peer_id = this.peerId;
    return this.vk.api.messages.send(params);
  }
  /**
   * Responds to the current message
   *
   * @param {string|Object} text
   * @param {Object}        params
   *
   * @return {Promise}
   */


  reply(text, params = {}) {
    if (typeof text !== 'object') {
      params.message = text;
    } else {
      params = text;
    }

    params.forward_messages = this.id;
    return this.send(params);
  }
  /**
   * Sends a sticker to the current dialog
   *
   * @param {number} id
   *
   * @return {Promise}
   */


  sendSticker(id) {
    return this.send({
      sticker_id: id
    });
  }
  /**
   * Sends a photo to the current dialog
   *
   * @param {mixed}  sourxe
   * @param {Object} params
   *
   * @return {Promise}
   */


  async sendPhoto(source, params = {}) {
    const attachment = await this.vk.upload.messagePhoto({
      peer_id: this.senderId,
      source
    });
    return await this.send(_objectSpread({}, params, {
      attachment
    }));
  }
  /**
   * Sends a document to the current dialog
   *
   * @param {mixed}  sourxe
   * @param {Object} params
   *
   * @return {Promise}
   */


  async sendDocument(source, params = {}) {
    const attachment = await this.vk.upload.messageDocument({
      peer_id: this.senderId,
      source
    });
    return await this.send(_objectSpread({}, params, {
      attachment
    }));
  }
  /**
   * Sends a voice to the current dialog
   *
   * @param {mixed}  sourxe
   * @param {Object} params
   *
   * @return {Promise}
   */


  async sendVoice(source, params = {}) {
    const attachment = await this.vk.upload.voice({
      peer_id: this.senderId,
      source
    });
    return await this.send(_objectSpread({}, params, {
      attachment
    }));
  }
  /**
   * Changes the status of typing in the dialog
   *
   * @return {Promise<boolean>}
   */


  async setActivity() {
    const isActivited = await this.vk.api.messages.setActivity({
      peer_id: this.peerId,
      type: 'typing'
    });
    return Boolean(isActivited);
  }
  /**
   * Marks messages as important or removes a mark.
   *
   * @param {Array}  ids
   * @param {Object} options
   *
   * @return {Promise<Array>}
   */


  async markAsImportant(ids = [this.id], options = {
    important: Number(!this.isImportant)
  }) {
    const messageIds = await this.vk.api.messages.markAsImportant(_objectSpread({}, options, {
      message_ids: ids.join(',')
    }));

    if (messageIds.includes(this.id)) {
      this.payload.important = Boolean(options.important);
    }

    return messageIds;
  }
  /**
   * Deletes the message
   *
   * @param {Array}  ids
   * @param {Object} options
   *
   * @return {Promise<number[]>}
   */


  async deleteMessage(ids = [this.id], options = {
    spam: 0
  }) {
    const messageIds = await this.vk.api.messages.delete(_objectSpread({}, options, {
      message_ids: ids.join(',')
    }));
    return messageIds;
  }
  /**
   * Restores the message
   *
   * @return {Promise<boolean>}
   */


  async restoreMessage() {
    const isRestored = await this.vk.api.messages.restore({
      message_id: this.id
    });
    return Boolean(isRestored);
  }
  /**
   * Allows you to join the chat by an invitation link
   *
   * @param {string} params
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  joinChatByInviteLink(link, params = {}) {
    return this.vk.api.messages.joinChatByInviteLink(_objectSpread({}, params, {
      link
    }));
  }
  /**
   * Checks that in a chat
   */


  assertIsChat() {
    if (!this.isChat) {
      throw new Error('This method is only available in chat');
    }
  }
  /**
   * Rename the chat
   *
   * @param {string} title
   *
   * @return {Promise<boolean>}
   */


  async renameChat(title) {
    this.assertIsChat();
    const isRenamed = await this.vk.api.messages.editChat({
      chat_id: this.chatId,
      title
    });
    return Boolean(isRenamed);
  }
  /**
   * Sets a new image for the chat
   *
   * @param {mixed}  source
   * @param {Object} params
   *
   * @return {Promise<Object>}
   */


  async newChatPhoto(source, params = {}) {
    this.assertIsChat();
    return await this.vk.upload.chatPhoto(_objectSpread({}, params, {
      chat_id: this.chatId,
      source
    }));
  }
  /**
   * Remove the chat photo
   *
   * @return {Promise<boolean>}
   */


  async deleteChatPhoto() {
    this.assertIsChat();
    return this.vk.api.messages.deleteChatPhoto({
      chat_id: this.chatId
    });
  }
  /**
   * Invites a new user
   *
   * @param {number} id
   *
   * @return {Promise<boolean>}
   */


  async inviteUser(id = this.eventMemberId) {
    this.assertIsChat();
    const isInvited = await this.vk.api.messages.removeChatUser({
      chat_id: this.chatId,
      user_id: id
    });
    return Boolean(isInvited);
  }
  /**
   * Excludes user
   *
   * @param {number} id
   *
   * @return {Promise<boolean>}
   */


  async kickUser(id = this.eventMemberId) {
    this.assertIsChat();
    const isKicked = await this.vk.api.messages.removeChatUser({
      chat_id: this.chatId,
      user_id: id
    });
    return Boolean(isKicked);
  }
  /**
   * Pins a message
   *
   * @return {Promise<boolean>}
   */


  async pinMessage() {
    this.assertIsChat();
    const isPinned = await this.vk.api.messages.pin({
      peer_id: this.peerId,
      message_id: this.id
    });
    return Boolean(isPinned);
  }
  /**
   * Unpins a message
   *
   * @return {Promise<boolean>}
   */


  async unpinMessage() {
    this.assertIsChat();
    const isUnpinned = await this.vk.api.messages.unpin({
      peer_id: this.peerId,
      message_id: this.id
    });
    return Boolean(isUnpinned);
  }

}

class WallPostContext extends Context {
  /**
   * constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    this.attachments = [new WallAttachment(payload, vk)];
    this.type = 'wall_post';
    this.subTypes = [updateType === 'wall_post_new' ? 'new_wall_post' : 'new_wall_repost'];
  }
  /**
   * Checks is repost
   *
   * @return {boolean}
   */


  get isRepost() {
    return this.subTypes.includes('new_wall_repost');
  }
  /**
   * Returns the wall attachment
   *
   * @return {WallAttachment}
   */


  get wall() {
    return this.attachments[0];
  }
  /**
   * Removes a record from the wall
   *
   * @return {Promise}
   */


  deletePost() {
    const wall = this.getWall;
    return this.vk.api.wall.delete({
      post_id: wall.id,
      owner_id: wall.ownerId
    });
  }

}

class StreamingContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload) {
    super(vk);
    this.payload = payload;
    const {
      action,
      event_type: type
    } = payload;
    this.attachments = transformAttachments(payload.attachments, vk);
    this.type = 'publication';
    this.subTypes = [`publication_${type}`, `${action}_publication`, `${action}_publication_${type}`];
  }
  /**
   * Checks is new object
   *
   * @return {boolean}
   */


  get isNew() {
    return this.actionType === 'new';
  }
  /**
   * Checks is update object
   *
   * @return {boolean}
   */


  get isUpdate() {
    return this.actionType === 'update';
  }
  /**
   * Checks is delete object
   *
   * @return {boolean}
   */


  get isDelete() {
    return this.actionType === 'delete';
  }
  /**
   * Checks is restore object
   *
   * @return {boolean}
   */


  get isRestore() {
    return this.actionType === 'restore';
  }
  /**
   * Checks is post event
   *
   * @return {boolean}
   */


  get isPost() {
    return this.eventType === 'post';
  }
  /**
   * Checks is share event
   *
   * @return {boolean}
   */


  get isShare() {
    return this.eventType === 'share';
  }
  /**
   * Checks is comment event
   *
   * @return {boolean}
   */


  get isComment() {
    return this.eventType === 'comment';
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.type === type);
  }
  /**
   * Returns the event URL
   *
   * @return {string}
   */


  get url() {
    return this.payload.event_url;
  }
  /**
   * Returns the creation time
   *
   * @return {number}
   */


  get date() {
    return this.payload.creation_time;
  }
  /**
   * Returns the text of the post
   *
   * @return {string}
   */


  get text() {
    return this.payload.text;
  }
  /**
   * Returns the text of the shared post
   *
   * @return {?string}
   */


  get sharedText() {
    return this.payload.shared_post_text || null;
  }
  /**
   * Returns the creation time from original post
   *
   * @return {?number}
   */


  get sharedDate() {
    return this.payload.shared_post_creation_time || null;
  }
  /**
   * Returns the action type
   *
   * @return {string}
   */


  get actionType() {
    return this.payload.action;
  }
  /**
   * Returns the event type
   *
   * @return {string}
   */


  get eventType() {
    return this.payload.event_type;
  }
  /**
   * Returns the creation time from
   *
   * @return {number}
   */


  get actionDate() {
    return this.payload.action_time;
  }
  /**
   * Returns the geo location
   *
   * @return {Object}
   */


  get geo() {
    return this.payload.geo;
  }
  /**
   * Returns the rule tags
   *
   * @return {Array}
   */


  get tags() {
    return this.payload.tags;
  }
  /**
   * Returns the identifier signer user
   *
   * @return {number}
   */


  get signerId() {
    return this.payload.signer_id;
  }
  /**
   * Returns the information of author
   *
   * @return {Object}
   */


  get author() {
    return this.payload.author;
  }
  /**
   * Returns the identifier author
   *
   * @return {number}
   */


  get authorId() {
    return this.payload.author.id;
  }
  /**
   * Returns the author url
   *
   * @return {string}
   */


  get authorUrl() {
    return this.payload.author.author_url;
  }
  /**
   * Returns the identifier of the author of the original post
   *
   * @return {?number}
   */


  get sharedAuthorId() {
    return this.payload.author.shared_post_author_id || null;
  }
  /**
   * Returns the author url of the original post
   *
   * @return {?string}
   */


  get sharedAuthorUrl() {
    return this.payload.author.shared_post_author_url || null;
  }
  /**
   * Returns the author platform
   *
   * @return {?string}
   */


  get authorPlatform() {
    return platforms.get(this.payload.author.platform);
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.type === type);
  }

}

/**
 * Causes of blocking
 *
 * @type {Map}
 */

const reasonNames = new Map([[0, 'other'], [1, 'spam'], [2, 'members_insult'], [3, 'obscene_expressions'], [4, 'messages_off_topic']]);
class GroupUserContext extends Context {
  /**
   * Constructror
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    this.type = 'group_user';
    this.subTypes = [updateType === 'user_block' ? 'block_group_user' : 'unblock_group_user'];
  }
  /**
   * Checks is join user
   *
   * @return {boolean}
   */


  get isBlock() {
    return this.subTypes.includes('block_group_user');
  }
  /**
   * Checks is leave user
   *
   * @return {boolean}
   */


  get isUnblock() {
    return this.subTypes.includes('unblock_group_user');
  }
  /**
   * Checks that the block has expired
   *
   * @return {?boolean}
   */


  get isExpired() {
    if (this.isBlock()) {
      return null;
    }

    return Boolean(this.payload.by_end_date);
  }
  /**
   * Returns the identifier admin
   *
   * @return {?number}
   */


  get adminId() {
    return this.payload.admin_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  get userId() {
    return this.payload.user_id;
  }
  /**
   * Returns the reason for the ban
   *
   * @return {?number}
   */


  get reasonId() {
    return this.payload.reason || null;
  }
  /**
   * Returns the reason name for the ban
   *
   * @return {?string}
   */


  get reasonName() {
    return reasonNames.get(this.reasonId);
  }
  /**
   * Returns the administrator comment to block
   *
   * @return {?string}
   */


  get comment() {
    return this.payload.comment || null;
  }
  /**
   * Adds a user to the community blacklist
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  banUser(params) {
    if (this.isBlock()) {
      return Promise.reject(new Error('User is blocked'));
    }

    return this.vk.api.groups.banUser(_objectSpread({}, params, {
      group_id: this.$groupId,
      user_id: this.userId
    }));
  }
  /**
   * Adds a user to the community blacklist
   *
   * @return {Promise}
   */


  unbanUser() {
    if (this.isUnblock()) {
      return Promise.reject(new Error('User is not blocked'));
    }

    return this.vk.api.groups.unbanUser({
      group_id: this.$groupId,
      user_id: this.userId
    });
  }

}

class UserOnlineContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, userId, extra, date]) {
    super(vk);
    this.payload = {
      user_id: -userId,
      extra,
      date
    };
    this.type = 'user_active';
    this.subTypes = [eventId === 8 ? 'user_online' : 'user_offline'];
  }
  /**
   * Checks that the user is online
   *
   * @return {boolean}
   */


  get isUserOnline() {
    return this.subTypes.includes('user_online');
  }
  /**
   * Checks that the user is online
   *
   * @return {boolean}
   */


  get isUserOffline() {
    return this.subTypes.includes('user_offline');
  }
  /**
   * Checks that the user has logged out of the network himself
   *
   * @return {boolean}
   */


  get isSelfExit() {
    return this.isUserOffline() && !this.payload.extra;
  }
  /**
   * Checks that the user logged out a timeout
   *
   * @return {boolean}
   */


  get isTimeoutExit() {
    return this.isUserOffline() && Boolean(this.payload.extra);
  }
  /**
   * Returns the date when this event was created
   *
   * @return {number}
   */


  get date() {
    return this.payload.date;
  }
  /**
   * Returns the name of the platform from which the user entered
   *
   * @return {?string}
   */


  get platformName() {
    return platforms.get(this.payload.extra);
  }

}

class DialogFlagsContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, peerId, flags]) {
    super(vk);
    this.payload = {
      peer_id: peerId,
      flags
    };
    this.type = 'dialog_flags';
    this.subTypes = [// eslint-disable-next-line no-nested-ternary
    eventId === 10 ? 'remove_dialog_flags' : eventId === 11 ? 'update_dialog_flags' : 'set_dialog_flags'];
  }
  /**
   * Checks that an important dialogue
   *
   * @return {boolean}
   */


  get isImportant() {
    return Boolean(this.flags & 1);
  }
  /**
   * Checks that the unanswered dialog
   *
   * @return {boolean}
   */


  get isUnanswered() {
    return Boolean(this.flags & 2);
  }
  /**
   * Returns the destination identifier
   *
   * @return {number}
   */


  get peerId() {
    return this.payload.peer_id;
  }
  /**
   * Returns the values of the flags
   *
   * @return {number}
   */


  get flags() {
    return this.payload.flags;
  }
  /**
   * Marks the dialog as answered or unchecked.
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  markAsAnsweredDialog(params) {
    return this.vk.api.messages.markAsAnsweredDialog(_objectSpread({}, params, {
      peer_id: this.peerId
    }));
  }
  /**
   * Marks the dialog as important or removes the mark
   *
   * @param {Object} params
   *
   * @return {Promise}
   */


  markAsImportantDialog(params) {
    return this.vk.api.messages.markAsImportantDialog(_objectSpread({}, params, {
      peer_id: this.peerId
    }));
  }

}

class GroupUpdateContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    const isChangePhoto = updateType === 'group_change_photo';
    this.attachments = isChangePhoto ? [new PhotoAttachment(payload.photo, vk)] : [];
    this.type = 'group_update';
    this.subTypes = [// eslint-disable-next-line no-nested-ternary
    updateType === 'group_change_settings' ? 'group_update_settings' : isChangePhoto ? 'group_update_photo' : 'group_update_officers'];
  }
  /**
   * Checks is change photo
   *
   * @return {boolean}
   */


  get isChangePhoto() {
    return this.subTypes.includes('group_change_photo');
  }
  /**
   * Checks is change officers
   *
   * @return {boolean}
   */


  get isChangeOfficers() {
    return this.subTypes.includes('group_change_officers');
  }
  /**
   * Checks is change settings
   *
   * @return {boolean}
   */


  get isChangeSettings() {
    return this.subTypes.includes('group_change_settings');
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.type === type);
  }
  /**
   * Returns the identifier admin
   *
   * @return {?number}
   */


  get adminId() {
    return this.payload.admin_id;
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  get userId() {
    return this.payload.user_id;
  }
  /**
   * Returns the old level permission
   *
   * @return {?number}
   */


  get oldLevel() {
    return this.payload.level_old || null;
  }
  /**
   * Returns the new level permission
   *
   * @return {?number}
   */


  get newLevel() {
    return this.payload.level_new || null;
  }
  /**
   * Returns the changes settings
   *
   * @return {?Object}
   */


  get changes() {
    return this.payload.changes || null;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.type === type);
  }

}

class GroupMemberContext extends Context {
  /**
   * Constructro
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    this.type = 'group_member';
    this.subTypes = [updateType === 'group_leave' ? 'leave_group_member' : 'join_group_member'];
  }
  /**
   * Checks is join user
   *
   * @return {boolean}
   */


  get isJoin() {
    return this.subTypes.includes('join_group_member');
  }
  /**
   * Checks is leave user
   *
   * @return {boolean}
   */


  get isLeave() {
    return this.subTypes.includes('leave_group_member');
  }
  /**
   * Checks is self leave user
   *
   * @return {?boolean}
   */


  get isSelfLeave() {
    if (this.isJoin()) {
      return null;
    }

    return Boolean(this.payload.self);
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  get userId() {
    return this.payload.user_id;
  }
  /**
   * Returns the join type
   *
   * @return {?string}
   */


  get joinType() {
    if (this.isLeave()) {
      return null;
    }

    return this.payload.join_type;
  }

}

class MessageAllowContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    this.type = 'message_subscribers';
    this.subTypes = [updateType === 'message_allow' ? 'message_subscribe' : 'message_unsubscribe'];
  }
  /**
   * Checks that the user has subscribed to messages
   *
   * @return {boolean}
   */


  get isSubscribed() {
    return this.subTypes.includes('message_subscribe');
  }
  /**
   * Checks that the user has unsubscribed from the messages
   *
   * @return {boolean}
   */


  get isUbsubscribed() {
    return this.subTypes.includes('message_unsubscribe');
  }
  /**
   * Returns the identifier user
   *
   * @return {number}
   */


  get userId() {
    return this.payload.user_id;
  }
  /**
   * Returns the key
   *
   * @return {?string}
   */


  get key() {
    return this.payload.key || null;
  }

}

class ReadMessagesContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, peerId, id]) {
    super(vk);
    this.payload = {
      peer_id: peerId,
      id
    };
    this.type = 'read_messages';
    this.subTypes = [eventId === 6 ? 'read_inbox_messages' : 'read_oubox_messages'];
  }
  /**
   * Checks that inbox messages are read
   *
   * @return {boolean}
   */


  get isInbox() {
    return this.subTypes.includes('read_inbox_messages');
  }
  /**
   * Checks that outbox messages are read
   *
   * @return {boolean}
   */


  get isOutbox() {
    return this.subTypes.includes('read_oubox_messages');
  }
  /**
   * Returns the ID before the message read
   *
   * @return {number}
   */


  get id() {
    return this.payload.id;
  }
  /**
   * Returns the peer ID
   *
   * @return {number}
   */


  get peerId() {
    return this.payload.peer_id;
  }

}

class MessageFlagsContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Array}  payload
   * @param {Object} options
   */
  constructor(vk, [eventId, id, flags, peerId]) {
    super(vk);
    this.payload = {
      peer_id: peerId,
      flags,
      id
    };
    this.type = 'message_flags';
    this.subTypes = [// eslint-disable-next-line no-nested-ternary
    eventId === 1 ? 'update_message_flags' : eventId === 2 ? 'set_message_flags' : 'remove_message_flags'];
  }
  /**
   * Verifies that the message is not read
   *
   * @return {boolean}
   */


  get isUnread() {
    return Boolean(this.flags & 1);
  }
  /**
   * Checks that the outgoing message
   *
   * @return {boolean}
   */


  get isOutbox() {
    return Boolean(this.flags & 2);
  }
  /**
   * Verifies that a reply has been created to the message
   *
   * @return {boolean}
   */


  get isReplied() {
    return Boolean(this.flags & 4);
  }
  /**
   * Verifies that the marked message
   *
   * @return {boolean}
   */


  get isImportant() {
    return Boolean(this.flags & 8);
  }
  /**
   * Verifies that the message was sent via chat
   *
   * @return {boolean}
   */


  get isChat() {
    return Boolean(this.flags & 16);
  }
  /**
   * Verifies that the message was sent by a friend
   *
   * @return {boolean}
   */


  get isFriends() {
    return Boolean(this.flags & 32);
  }
  /**
   * Verifies that the message is marked as "Spam"
   *
   * @return {boolean}
   */


  get isSpam() {
    return Boolean(this.flags & 64);
  }
  /**
   * Verifies that the message has been deleted (in the Recycle Bin)
   *
   * @return {boolean}
   */


  get isDeleted() {
    return Boolean(this.flags & 128);
  }
  /**
   * Verifies that the message was verified by the user for spam
   *
   * @return {boolean}
   */


  get isFixed() {
    return Boolean(this.flags & 256);
  }
  /**
   * Verifies that the message contains media content
   *
   * @return {boolean}
   */


  get isMedia() {
    return Boolean(this.flags & 512);
  }
  /**
   * Checks that a welcome message from the community
   *
   * @return {boolean}
   */


  get isHidden() {
    return Boolean(this.flags & 65536);
  }
  /**
   * Returns the message ID
   *
   * @return {number}
   */


  get id() {
    return this.payload.id;
  }
  /**
   * Returns the destination identifier
   *
   * @return {number}
   */


  get peerId() {
    return this.payload.peer_id;
  }
  /**
   * Returns the values of the flags
   *
   * @return {number}
   */


  get flags() {
    return this.payload.flags;
  }

}

/**
 * Find types
 *
 * @example wall_reply_new
 *
 * @type {RegExp}
 */

const findTypes = /([^_]+)_([^_]+)_([^_]+)/;
class CommentActionContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    this.attachments = transformAttachments(payload.attachments, vk);
    const {
      1: initsiator,
      3: action
    } = updateType.match(findTypes);
    this.type = 'comment';
    this.subTypes = [`${initsiator}_comment`, `${action}_${initsiator}_comment`];
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.type === type);
  }
  /**
   * Checks is new comment
   *
   * @return {boolean}
   */


  get isNew() {
    return this.includesFromSubType('new');
  }
  /**
   * Checks is edit comment
   *
   * @return {boolean}
   */


  get isEdit() {
    return this.includesFromSubType('edit');
  }
  /**
   * Checks is delete comment
   *
   * @return {boolean}
   */


  get isDelete() {
    return this.includesFromSubType('delete');
  }
  /**
   * Checks is restore comment
   *
   * @return {boolean}
   */


  get isRestore() {
    return this.includesFromSubType('restore');
  }
  /**
   * Checks is photo comment
   *
   * @return {boolean}
   */


  get isPhotoComment() {
    return this.includesFromSubType('photo');
  }
  /**
   * Checks is wall comment
   *
   * @return {boolean}
   */


  get isWallComment() {
    return this.includesFromSubType('wall');
  }
  /**
   * Checks is video comment
   *
   * @return {boolean}
   */


  get isVideoComment() {
    return this.includesFromSubType('video');
  }
  /**
   * Checks is board comment
   *
   * @return {boolean}
   */


  get isBoardComment() {
    return this.includesFromSubType('board');
  }
  /**
   * Checks is board comment
   *
   * @return {boolean}
   */


  get isMarketComment() {
    return this.includesFromSubType('market');
  }
  /**
   * Checks is reply comment
   *
   * @return {boolean}
   */


  get isReply() {
    return 'reply_to_comment' in this.payload;
  }
  /**
   * Returns the identifier comment
   *
   * @return {number}
   */


  get id() {
    return this.payload.id;
  }
  /**
   * Returns the identifier reply comment
   *
   * @return {?number}
   */


  get replyId() {
    return this.payload.reply_to_comment || null;
  }
  /**
   * Returns the identifier user
   *
   * @return {?number}
   */


  get userId() {
    return this.payload.from_id || this.payload.user_id || null;
  }
  /**
   * Returns the identifier reply user
   *
   * @return {?number}
   */


  get replyUserId() {
    return this.payload.reply_to_user || null;
  }
  /**
   * Returns the identifier of the user who deleted the comment
   *
   * @return {?number}
   */


  get removerUserId() {
    return this.payload.deleter_id || null;
  }
  /**
   * Returns the identifier of object
   *
   * @return {?number}
   */


  get objectId() {
    const {
      payload
    } = this;
    return payload.photo_id || payload.video_id || payload.post_id || payload.topic_id || payload.item_id || null;
  }
  /**
   * Returns the identifier of owner
   *
   * @return {?number}
   */


  get ownerId() {
    const {
      payload
    } = this;
    return payload.owner_id || payload.photo_owner_id || payload.video_owner_id || payload.post_owner_id || payload.topic_owner_id || payload.market_owner_id || null;
  }
  /**
   * Returns the date creation action comment
   *
   * @return {?number}
   */


  get date() {
    return this.payload.date || null;
  }
  /**
   * Returns the text comment
   *
   * @return {?string}
   */


  get text() {
    return this.payload.text || null;
  }
  /**
   * Returns the likes
   *
   * @return {?Object}
   */


  get likes() {
    return this.payload.likes;
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.type === type);
  }
  /**
   * Includes from subtype
   *
   * @param {string} type
   *
   * @return {string}
   */


  includesFromSubType(type) {
    return this.subTypes[1].includes(type);
  }
  /**
   * Edits a comment
   *
   * @param {Object} options
   *
   * @return {Promise}
   */


  editComment(options) {
    if (this.isDelete()) {
      return Promise.reject(new Error('Comment is deleted'));
    }

    if (this.isBoardComment()) {
      return this.vk.api.board.editComment(_objectSpread({}, options, {
        comment_id: this.id,
        topic_id: this.objectId,
        group_id: this.$groupId
      }));
    }

    const params = _objectSpread({}, options, {
      comment_id: this.id,
      owner_id: this.ownerId
    });

    if (this.isPhotoComment()) {
      return this.vk.api.photos.editComment(params);
    }

    if (this.isVideoComment()) {
      return this.vk.api.video.editComment(params);
    }

    if (this.isWallComment()) {
      return this.vk.api.wall.editComment(params);
    }

    if (this.isMarketComment()) {
      return this.vk.api.market.editComment(params);
    }

    return Promise.reject(new Error('Unsupported event for editing comment'));
  }
  /**
   * Removes comment
   *
   * @return {Promise}
   */


  deleteComment() {
    if (this.isDelete()) {
      return Promise.reject(new Error('Comment is deleted'));
    }

    if (this.isBoardComment()) {
      return this.vk.api.board.deleteComment({
        comment_id: this.id,
        topic_id: this.objectId,
        group_id: this.$groupId
      });
    }

    const params = {
      comment_id: this.id,
      owner_id: this.ownerId
    };

    if (this.isPhotoComment()) {
      return this.vk.api.photos.deleteComment(params);
    }

    if (this.isVideoComment()) {
      return this.vk.api.video.deleteComment(params);
    }

    if (this.isWallComment()) {
      return this.vk.api.wall.deleteComment(params);
    }

    if (this.isMarketComment()) {
      return this.vk.api.market.deleteComment(params);
    }

    return Promise.reject(new Error('Unsupported event for deleting comment'));
  }

}

class NewAttachmentsContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Object} payload
   * @param {Object} options
   */
  constructor(vk, payload, {
    updateType,
    groupId
  }) {
    super(vk);
    this.payload = payload;
    this.$groupId = groupId;
    let subType;
    let attachment; // eslint-disable-next-line default-case

    switch (updateType) {
      case 'photo_new':
        {
          subType = 'new_photo_attachment';
          attachment = new PhotoAttachment(payload, vk);
          break;
        }

      case 'video_new':
        {
          subType = 'new_video_attachment';
          attachment = new VideoAttachment(payload, vk);
          break;
        }

      case 'audio_new':
        {
          subType = 'new_audio_attachment';
          attachment = new AudioAttachment(payload, vk);
          break;
        }
    }

    this.attachments = [attachment];
    this.type = 'new_attachment';
    this.subTypes = [subType];
  }
  /**
   * Checks is attachment photo
   *
   * @return {boolean}
   */


  get isPhoto() {
    return this.subTypes.includes('new_photo');
  }
  /**
   * Checks is attachment video
   *
   * @return {boolean}
   */


  get isVideo() {
    return this.subTypes.includes('new_video');
  }
  /**
   * Checks is attachment audio
   *
   * @return {boolean}
   */


  get isAudio() {
    return this.subTypes.includes('new_audio');
  }
  /**
   * Checks for the presence of attachments
   *
   * @param {?string} type
   *
   * @return {boolean}
   */


  hasAttachments(type = null) {
    if (type === null) {
      return this.attachments.length > 0;
    }

    return this.attachments.some(attachment => attachment.type === type);
  }
  /**
   * Returns the attachments
   *
   * @param {?string} type
   *
   * @return {Array}
   */


  getAttachments(type = null) {
    if (type === null) {
      return this.attachments;
    }

    return this.attachments.filter(attachment => attachment.type === type);
  }
  /**
   * Removes the attachment
   *
   * @return {Promise}
   */


  deleteAttachment() {
    if (this.isPhoto()) {
      const [photo] = this.getAttachments('photo');
      return this.vk.api.photos.delete({
        owner_id: photo.ownerId,
        photo_id: photo.id
      });
    }

    if (this.isVideo()) {
      const [video] = this.getAttachments('video');
      return this.vk.api.video.delete({
        owner_id: video.ownerId,
        video_id: video.id
      });
    }

    if (this.isAudio()) {
      const [audio] = this.getAttachments('audio');
      return this.vk.api.audio.delete({
        owner_id: audio.ownerId,
        audio_id: audio.id
      });
    }

    return Promise.reject(new Error('Unsupported event for deleting attachment'));
  }

}

class RemovedMessagesContext extends Context {
  /**
   * Constructor
   *
   * @param {VK}     vk
   * @param {Arrray} payload
   * @param {Object} options
   */
  constructor(vk, [eventId, peerId, id]) {
    super(vk);
    this.payload = {
      peer_id: peerId,
      id
    };
    this.type = 'removed_messages';
    this.subTypes = [eventId === 13 ? 'delete_messages' : 'restore_messages'];
  }
  /**
   * Checks that messages have been deleted
   *
   * @return {boolean}
   */


  get isRemoved() {
    return this.subTypes.includes('delete_messages');
  }
  /**
   * Checks that messages have been restored
   *
   * @return {boolean}
   */


  get isRecovery() {
    return this.subTypes.includes('restore_messages');
  }
  /**
   * Returns the identifier of the message
   *
   * @return {string}
   */


  get id() {
    return this.payload.id;
  }
  /**
   * Returns the peer ID
   *
   * @return {number}
   */


  get peerId() {
    return this.payload.peer_id;
  }

}

const {
  URL: URL$7,
  URLSearchParams: URLSearchParams$6
} = nodeUrl;
const {
  inspect: inspect$b,
  promisify: promisify$2
} = nodeUtil;
const {
  NEED_RESTART,
  POLLING_REQUEST_FAILED
} = updatesErrors;
const debug$8 = createDebug('vk-io:updates');
/**
 * Version polling
 *
 * @type {number}
 */

const POLLING_VERSION = 3;
const webhookContextsEvents = [[['message_new', 'message_edit', 'message_reply'], MessageContext], [['message_allow', 'message_deny'], MessageAllowContext], [['photo_new', 'audio_new', 'video_new'], NewAttachmentsContext], [['wall_post_new', 'wall_repost'], WallPostContext], [['group_join', 'group_leave'], GroupMemberContext], [['user_block', 'user_unblock'], GroupUserContext], [['photo_comment_new', 'photo_comment_edit', 'photo_comment_delete', 'photo_comment_restore', 'video_comment_new', 'video_comment_edit', 'video_comment_delete', 'video_comment_restore', 'wall_reply_new', 'wall_reply_edit', 'wall_reply_delete', 'wall_reply_restore', 'board_reply_new', 'board_reply_edit', 'board_reply_delete', 'board_reply_restore', 'market_reply_new', 'market_reply_edit', 'market_reply_delete', 'market_reply_restore'], CommentActionContext], [['poll_vote_new'], VoteContext], [['group_change_photo', 'group_officers_edit', 'group_change_settings'], GroupUpdateContext]];
const pollingContextsEvents = [[[1, 2, 3], MessageFlagsContext], [[4, 5], MessageContext], [[6, 7], ReadMessagesContext], [[8, 9], UserOnlineContext], [[10, 11, 12], DialogFlagsContext], [[13, 14], RemovedMessagesContext], [[61, 62], TypingContext]];

const makeContexts = groups => {
  const contexts = {};

  for (const [events, Context$$1] of groups) {
    for (const event of events) {
      contexts[event] = Context$$1;
    }
  }

  return contexts;
};

const webhookContexts = makeContexts(webhookContextsEvents);
const pollingContexts = makeContexts(pollingContextsEvents);
class Updates {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.restarted = 0;
    this.started = null;
    this.url = null;
    this.ts = null;
    this.pts = null;
    /**
     * 2 -  Attachments
     * 8 -  Extended events
     * 64 - Online user platform ID
     *
     * @type {number}
     */

    this.mode = 2 | 8 | 64;
    this.webhookServer = null;
    this.stack = [];
    this.middleware = null;
    this.hears = new Middleware();

    this.hearFallbackHandler = (context, next) => next();

    this.reloadMiddleware();
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Updates';
  }
  /**
   * Checks is started
   *
   * @return {boolean}
   */


  isStarted() {
    return this.started !== null;
  }
  /**
   * Added middleware
   *
   * @param {Function} handler
   *
   * @return {this}
   */


  use(middleware) {
    this.stack.push(middleware);
    this.reloadMiddleware();
    return this;
  }
  /**
   * Subscribe to events
   *
   * @param {string[]} events
   * @param {Function} handler
   *
   * @return {this}
   */


  on(events, handler) {
    if (!Array.isArray(events)) {
      events = [events];
    }

    const hasNull = events.some(event => !event);

    if (hasNull) {
      throw new Error('Events should be not null');
    }

    return this.use((context, next) => context.is(events) ? handler(context, next) : next());
  }
  /**
   * Listen text
   *
   * @param {Mixed[]}  condition
   * @param {Function} handler
   *
   * @return {this}
   */


  hear(conditions, handler) {
    if (!Array.isArray(conditions)) {
      conditions = [conditions];
    }

    const hasNull = conditions.some(condition => !condition);

    if (hasNull) {
      throw new Error('Condition should be not null');
    }

    this.hears.use((context, next) => {
      const {
        text
      } = context;
      const hasSome = conditions.some(condition => {
        if (typeof condition === 'function') {
          return condition(text, context);
        }

        if (condition instanceof RegExp) {
          const passed = condition.test(text);

          if (passed) {
            context.$match = text.match(condition);
          }

          return passed;
        }

        return text === condition;
      });
      return hasSome ? handler(context, next) : next();
    });
    return this;
  }
  /**
   * A handler that is called when handlers are not found
   *
   * @param {Function} handler
   *
   * @return {this}
   */


  setHearFallbackHandler(handler) {
    this.hearFallbackHandler = handler;
    return this;
  }
  /**
   * Handles longpoll event
   *
   * @param {Array} update
   *
   * @return {Promise}
   */


  handlePollingUpdate(update) {
    debug$8('longpoll update', update);
    const [type] = update;
    const Context$$1 = pollingContexts[type];

    if (!Context$$1) {
      debug$8(`Unsupported polling context type ${type}`);
      return null;
    }

    return this.dispatchMiddleware(new Context$$1(this.vk, update, {
      source: updatesSources.POLLING,
      updateType: type
    }));
  }
  /**
   * Handles webhook event
   *
   * @param {Object} update
   *
   * @return {Promise}
   */


  handleWebhookUpdate(update) {
    debug$8('webhook update', update);
    const {
      type,
      object: payload,
      group_id: groupId
    } = update;
    const Context$$1 = webhookContexts[type];

    if (!Context$$1) {
      debug$8(`Unsupported webhook context type ${type}`);
      return null;
    }

    return this.dispatchMiddleware(new Context$$1(this.vk, payload, {
      source: updatesSources.WEBHOOK,
      updateType: type,
      groupId
    }));
  }
  /**
   * Starts to poll server
   *
   * @return {Promise}
   */


  async startPolling() {
    if (this.started !== null) {
      debug$8(`Updates already started: ${this.started}`);
      return;
    }

    this.started = 'polling';

    try {
      const {
        pollingGroupId
      } = this.vk.options;
      const isGroup = pollingGroupId !== null;
      const {
        server,
        key,
        ts
      } = isGroup ? await this.vk.api.groups.getLongPollServer({
        group_id: pollingGroupId
      }) : await this.vk.api.messages.getLongPollServer({
        lp_version: POLLING_VERSION
      });

      if (this.ts === null) {
        this.ts = ts;
      }

      const pollingURL = isGroup ? server : `https://${server}`;
      this.url = new URL$7(pollingURL);
      this.url.search = new URLSearchParams$6({
        act: 'a_check',
        version: POLLING_VERSION,
        wait: 25,
        key
      });
      this.startFetchLoop();
    } catch (error) {
      this.started = null;
      throw error;
    }
  }
  /**
   * Starts the webhook server
   *
   * @param {Function} next
   *
   * @return {Promise}
   */


  async startWebhook({
    tls,
    path,
    port,
    host
  } = {}, next) {
    if (this.started !== null) {
      debug$8(`Updates already started: ${this.started}`);
      return;
    }

    this.started = 'webhook';

    try {
      const {
        webhookPath
      } = this.vk.options;
      const webhookCallback = this.getWebhookCallback(path || webhookPath || '/');
      const callback = typeof next === 'function' ? (req, res) => webhookCallback(req, res, () => next(req, res)) : webhookCallback;
      this.webhookServer = tls ? nodeHttps.createServer(tls, callback) : nodeHttp.createServer(callback);

      if (!port) {
        port = tls ? 443 : 80;
      }

      const {
        webhookServer
      } = this;
      const listen = promisify$2(webhookServer.listen).bind(webhookServer);
      await listen(port, host);
      debug$8(`Webhook listening on port: ${port}`);
    } catch (error) {
      this.started = null;
      throw error;
    }
  }
  /**
   * Stopping gets updates
   *
   * @return {Promise}
   */


  async stop() {
    this.started = null;
    this.restarted = 0;

    if (this.webhookServer !== null) {
      const {
        webhookServer
      } = this;
      const close = promisify$2(webhookServer.close).bind(webhookServer);
      await close();
      this.webhookServer = null;
    }
  }
  /**
   * Returns webhook callback like http[s] or express
   *
   * @param {string} path
   *
   * @return {Function}
   */


  getWebhookCallback(path = null) {
    const isEmptyPath = path !== null;
    const headers = {
      connection: 'keep-alive',
      'content-type': 'text/plain'
    };
    return (req, res, next) => {
      if (req.method !== 'POST' || isEmptyPath && req.url !== path) {
        if (typeof next === 'function') {
          next();
          return;
        }

        res.writeHead(403);
        res.end();
        return;
      }

      let body = '';
      req.on('data', chunk => {
        if (body.length > 1e6) {
          body = null;
          res.writeHead(413);
          res.end();
          req.connection.destroy();
          return;
        }

        body += String(chunk);
      });
      req.on('end', () => {
        try {
          const update = JSON.parse(body);
          const {
            webhookSecret,
            webhookConfirmation
          } = this.vk.options;

          if (webhookSecret !== null && update.secret !== webhookSecret) {
            res.writeHead(403);
            res.end();
            return;
          }

          if (update.type === 'confirmation') {
            if (webhookConfirmation === null) {
              res.writeHead(500);
              res.end();
              return;
            }

            res.writeHead(200, headers);
            res.end(String(webhookConfirmation));
            return;
          }

          res.writeHead(200, headers);
          res.end('ok');
          this.handleWebhookUpdate(update).catch(error => {
            // eslint-disable-next-line no-console
            console.error('Handle webhook update error', error);
          });
        } catch (error) {
          debug$8('webhook error', error);
          res.writeHead(415);
          res.end();
        }
      });
    };
  }
  /**
   * Returns the middleware for the webhook under koa
   *
   * @param {Object} options
   *
   * @return {Function}
   */


  getKoaWebhookMiddleware() {
    return async context => {
      const update = context.request.body;
      const {
        webhookSecret,
        webhookConfirmation
      } = this.vk.options;

      if (webhookSecret !== null && update.secret !== webhookSecret) {
        context.status = 403;
        return;
      }

      if (update.type === 'confirmation') {
        if (webhookConfirmation === null) {
          context.status = 500;
          return;
        }

        context.body = webhookConfirmation;
        return;
      }

      context.body = 'ok';
      context.set('connection', 'keep-alive');
      /* Do not delay server response */

      this.handleWebhookUpdate(update).catch(error => {
        // eslint-disable-next-line no-console
        console.error('Handle webhook update error', error);
      });
    };
  }
  /**
   * Starts forever fetch updates  loop
   *
   * @return {Promise}
   */


  async startFetchLoop() {
    try {
      while (this.started === 'polling') {
        await this.fetchUpdates();
      }
    } catch (error) {
      debug$8('longpoll error', error);
      const {
        pollingWait,
        pollingAttempts
      } = this.vk.options;

      if (error.code !== NEED_RESTART && this.restarted < pollingAttempts) {
        this.restarted += 1;
        debug$8('longpoll restart request');
        await delay(3e3);
        this.startFetchLoop();
        return;
      }

      while (this.started === 'polling') {
        try {
          await this.stop();
          await this.startPolling();
          break;
        } catch (restartError) {
          debug$8('longpoll restarted error', restartError);
          this.started = 'polling';
          await delay(pollingWait);
        }
      }
    }
  }
  /**
   * Gets updates
   *
   * @return {Promise}
   */


  async fetchUpdates() {
    const {
      agent
    } = this.vk.options;
    const {
      searchParams
    } = this.url;
    searchParams.set('ts', this.ts);
    searchParams.set('mode', this.mode);
    debug$8('http -->');
    let response = await fetch(this.url, {
      agent,
      method: 'GET',
      timeout: 30e3,
      compress: false,
      headers: {
        connection: 'keep-alive'
      }
    });
    debug$8(`http <-- ${response.status}`);

    if (!response.ok) {
      throw new UpdatesError({
        code: POLLING_REQUEST_FAILED,
        message: 'Polling request failed'
      });
    }

    response = await response.json();
    this.restarted = 0;

    if ('failed' in response && response.failed !== 1) {
      this.ts = null;
      throw new UpdatesError({
        code: NEED_RESTART,
        message: 'The server has failed'
      });
    }

    this.ts = Number(response.ts);

    if ('pts' in response) {
      this.pts = Number(response.pts);
    }

    if ('updates' in response) {
      const isGroup = this.vk.options.pollingGroupId !== null;
      /* Async handle updates */

      Promise.all(response.updates.map(async update => {
        try {
          if (isGroup) {
            await this.handleWebhookUpdate(update);
          } else {
            await this.handlePollingUpdate(update);
          }
        } catch (error) {
          // eslint-disable-next-line no-console
          console.error('Handle polling update error:', error);
        }
      }));
    }
  }
  /**
   * Calls up the middleware chain
   *
   * @param {Context} context
   *
   * @return {Promise<void>}
   */


  dispatchMiddleware(context) {
    return this.middleware.run(context);
  }
  /**
   * Reloads middleware
   */


  reloadMiddleware() {
    this.middleware = new Middleware(this.stack);
    this.middleware.use(async (context, next) => {
      if (!context.is('text')) {
        await next();
        return;
      }

      const {
        finished
      } = await this.hears.run(context);

      if (finished) {
        await this.hearFallbackHandler(context, next);
      }
    });
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$b.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      stack
    } = this;
    const payload = {
      started,
      stack
    };
    return `${options.stylize(name, 'special')} ${inspect$b(payload, options)}`;
  }

}

const {
  URL: URL$8
} = nodeUrl;
const {
  INVALID_URL,
  URL_NOT_ALLOWED,
  RESOURCE_NOT_FOUND
} = snippetsErrors;
/**
 * Remove search param
 *
 * @type {RegExp}
 */

const removeSearchParam = /(\?|&)[^=]+=/;
/**
 * Search dot
 *
 * @type {RegExp}
 */

const searchDot = /\./g;
/**
 * Switch resource types
 *
 * @type {Object}
 */

const enumResourceTypes = {
  id: 'user',
  club: 'group',
  public: 'group',
  app: 'application'
};
/**
 * Allowed host names
 *
 * @type {Array}
 */

const allowedHostnames = ['vk.com', 'm.vk.com'];
/**
 * Resolve the attachment resource
 *
 * @param {string} resource
 * @param {RegExp} pattern
 *
 * @return {Object}
 */

const resolveOwnerResource = (resource, pattern) => {
  const [, type, owner, id] = resource.match(pattern);
  return {
    id: Number(id),
    owner: Number(owner),
    type: type.toLowerCase().replace(removeSearchParam, '')
  };
};

class Snippets {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Snippets';
  }
  /**
   * Defines the type of object (user, community, application, attachment)
   *
   * @param {string} resource
   *
   * @return {Promise<Object>}
   */


  async resolveResource(resource) {
    if (!resource) {
      throw new Error('Resource should must be');
    }

    resource = String(resource);

    if (resource.startsWith('@') || resource.startsWith('*')) {
      resource = resource.substring(1);
    }

    const numberResource = Number(resource);
    const resourceIsNaN = Number.isNaN(numberResource);

    if (!resourceIsNaN) {
      const isUser = numberResource > 0;
      return {
        id: isUser ? numberResource : -numberResource,
        type: isUser ? 'user' : 'group'
      };
    }

    let resourceSearch;

    try {
      if (!resource.match(searchDot)) {
        throw new Error('Is not URL');
      }

      let url = resource;

      if (!(url.startsWith('http://') || url.startsWith('https://'))) {
        url = `https://${resource}`;
      }

      const {
        hostname,
        pathname,
        search
      } = new URL$8(url);

      if (!allowedHostnames.includes(hostname)) {
        throw new SnippetsError({
          code: URL_NOT_ALLOWED,
          message: 'URL not allowed'
        });
      }

      if (pathname === '/') {
        throw new SnippetsError({
          code: INVALID_URL,
          message: 'URL should contain path'
        });
      }

      resource = pathname.substring(1);
      resourceSearch = search;
    } catch (error) {
      if ([URL_NOT_ALLOWED, INVALID_URL].includes(error.code)) {
        throw error;
      }
    }

    if (parseAttachment.test(resourceSearch)) {
      return resolveOwnerResource(resourceSearch, parseAttachment);
    }

    if (parseOwnerResource.test(resourceSearch)) {
      return resolveOwnerResource(resourceSearch, parseOwnerResource);
    }

    if (parseAttachment.test(resource)) {
      return resolveOwnerResource(resource, parseAttachment);
    }

    if (parseOwnerResource.test(resource)) {
      return resolveOwnerResource(resource, parseOwnerResource);
    }

    if (parseResource.test(resource)) {
      const [, typeResource, id] = resource.match(parseResource);
      let type = typeResource.toLowerCase();

      if (type in enumResourceTypes) {
        // eslint-disable-next-line prefer-destructuring
        type = enumResourceTypes[type];
      }

      return {
        id: Number(id),
        type
      };
    }

    const response = await this.vk.api.utils.resolveScreenName({
      screen_name: resource
    });

    if (Array.isArray(response)) {
      throw new SnippetsError({
        message: 'Resource not found',
        code: RESOURCE_NOT_FOUND
      });
    }

    const {
      type,
      object_id: id
    } = response;

    if (type === 'page') {
      return {
        id,
        type: 'group'
      };
    }

    return {
      id,
      type
    };
  }

}

const {
  URL: URL$9,
  URLSearchParams: URLSearchParams$7
} = nodeUrl;
const {
  inspect: inspect$c,
  promisify: promisify$3
} = nodeUtil;
const debug$9 = createDebug('vk-io:streaming');
class StreamingAPI {
  /**
   * Constructor
   *
   * @param {VK} vk
   */
  constructor(vk) {
    this.vk = vk;
    this.key = null;
    this.socket = null;
    this.endpoint = null;
    this.started = null;
    this.handlers = [];
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'StreamingAPI';
  }
  /**
   * Starts websocket
   *
   * @return {Promise}
   */


  async startWebSocket() {
    this.started = 'websocket';

    try {
      const {
        key,
        endpoint
      } = await this.vk.api.streaming.getServerUrl();
      this.key = key;
      this.endPoint = new URL$9(`https://${endpoint}`);
      const search = new URLSearchParams$7({
        key
      });
      const {
        agent
      } = this.vk.options;
      this.socket = new WebSocket(`wss://${endpoint}/stream?${search}`, {
        agent
      });
    } catch (error) {
      this.started = null;
      throw error;
    }

    const {
      socket
    } = this;
    this.close = promisify$3(socket.close).bind(socket);
    socket.on('message', data => {
      let message;

      try {
        message = JSON.parse(data);
      } catch (error) {
        debug$9('JSON parse failed', error);
        return;
      }

      const {
        code
      } = message;

      try {
        switch (code) {
          case 100:
            {
              this.handleEvent(message.event);
              break;
            }

          case 300:
            {
              this.handleServiceMessage(message.service_message);
              break;
            }

          default:
            debug$9(`Unsupported message code: ${code}`);
        }
      } catch (error) {
        // eslint-disable-next-line no-console
        console.log('Handle event error', error);
      }
    });
    socket.on('error', error => {
      debug$9('WebSocket error', error);
    });
  }
  /**
   * Stop all connection
   *
   * @return {Promise}
   */


  async stop() {
    if (this.started === null) {
      return;
    }

    await this.close();
    this.started = null;
    this.key = null;
    this.socket = null;
    this.endpoint = null;
  }
  /**
   * Processes server messages
   *
   * @param {Object} serviceMessage
   *
   * @return {Promise}
   */


  async handleServiceMessage({
    service_code: code
  }) {
    if ([3000, 3001].includes(code)) {
      await this.stop();
      await this.start();
    }
  }
  /**
   * Handles events
   *
   * @param {Object} event
   *
   * @return {Promise}
   */


  async handleEvent(event) {
    const context = new StreamingContext(this.vk, event);
    return await this.vk.updates.dispatchMiddleware(context);
  }
  /**
   * Executes the HTTP request for rules
   *
   * @param {string} method
   * @param {Object} options
   *
   * @return {Promise<Object>}
   */


  async fetchRules(method, payload = {}) {
    const {
      agent
    } = this.vk.options;
    const url = new URL$9('/rules', this.endPoint);
    url.searchParams.set('key', this.key);
    let body;

    if (method !== 'GET') {
      body = JSON.stringify(payload);
    }

    let response = await fetch(url, {
      agent,
      method,
      body,
      headers: {
        'content-type': 'application/json'
      }
    });
    response = await response.json();

    if ('error' in response) {
      throw new StreamingRuleError(response.error);
    }

    return response;
  }
  /**
   * Returns a list of rules
   *
   * @return {Promise<Array>}
   */


  async getRules() {
    const {
      rules = []
    } = await this.fetchRules('GET');
    return rules;
  }
  /**
   * Adds a rule
   *
   * @param {Object} rule
   *
   * @return {Promise}
   */


  addRule(rule) {
    return this.fetchRules('POST', {
      rule
    });
  }
  /**
   * Removes the rule
   *
   * @param {string} tag
   *
   * @return {Promise}
   */


  deleteRule(tag) {
    return this.fetchRules('DELETE', {
      tag
    });
  }
  /**
   * Adds a list of rules
   *
   * @param {Array} rules
   *
   * @return {Promise}
   */


  addRules(rules) {
    return Promise.all(rules.map(rule => this.addRule(rule)));
  }
  /**
   * Removes all rules
   *
   * @return {Promise}
   */


  async deleteRules() {
    const rules = await this.getRules();
    return await Promise.all(rules.map(({
      tag
    }) => this.deleteRule(tag)));
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$c.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      started,
      handlers
    } = this;
    const payload = {
      started,
      handlers
    };
    return `${options.stylize(name, 'special')} ${inspect$c(payload, options)}`;
  }

}

const {
  Agent
} = nodeHttps;
const {
  inspect: inspect$d
} = nodeUtil;
/**
 * Main class
 *
 * @public
 */

class VK {
  /**
   * Constructor
   *
   * @param {Object} options
   */
  constructor(options = {}) {
    this.options = _objectSpread({}, defaultOptions, {
      agent: new Agent({
        keepAlive: true,
        keepAliveMsecs: 10000
      })
    });
    this.setOptions(options);
    this.api = new API(this);
    this.auth = new Auth(this);
    this.upload = new Upload(this);
    this.collect = new Collect(this);
    this.updates = new Updates(this);
    this.snippets = new Snippets(this);
    this.streaming = new StreamingAPI(this);
    this.captchaHandler = null;
    this.twoFactorHandler = null;
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'VK';
  }
  /**
   * Sets options
   *
   * @param {Object} options
   *
   * @return {this}
   */


  setOptions(options) {
    Object.assign(this.options, options);
    return this;
  }
  /**
   * Sets token
   *
   * @param {string} token
   *
   * @return {this}
   */


  setToken(token) {
    this.options.token = token;
    return this;
  }
  /**
   * Returns token
   *
   * @return {?string}
   */


  getToken() {
    return this.options.token;
  }
  /**
   * Sets captcha handler
   *
   * @param {?Function} handler
   *
   * @return {this}
   *
   * @example
   * 	vk.setCaptchaHandler((payload, retry) => {...});
   */


  setCaptchaHandler(handler) {
    this.captchaHandler = handler;
    return this;
  }
  /**
   * Sets two-factor handler
   *
   * @param {?Function} handler
   *
   * @return {this}
   *
   * @example
   * 	vk.setTwoFactorHandler((payload, retry) => {...});
   */


  setTwoFactorHandler(handler) {
    this.twoFactorHandler = handler;
    return this;
  }
  /**
   * Custom inspect object
   *
   * @param {?number} depth
   * @param {Object}  options
   *
   * @return {string}
   */


  [inspect$d.custom](depth, options) {
    const {
      name
    } = this.constructor;
    const {
      api,
      updates,
      streaming,
      captchaHandler,
      twoFactorHandler
    } = this;
    const {
      app,
      token,
      login,
      phone
    } = this.options;
    const payload = {
      options: {
        app,
        login,
        phone,
        token
      },
      captchaHandler,
      twoFactorHandler,
      api,
      updates,
      streaming
    };
    return `${options.stylize(name, 'special')} ${inspect$d(payload, options)}`;
  }

}

class Button {
  /**
   * Constructor
   *
   * @param {Object} options
   */
  constructor({
    color = Button.DEFAULT_COLOR,
    action
  }) {
    this.color = color;
    const payload = JSON.stringify(action.payload || {});

    if (payload.length > 255) {
      throw new VKError({
        message: 'Maximum length of payload 255 characters'
      });
    }

    this.action = _objectSpread({}, action, {
      payload
    });
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /**
   * Returns the default color (#FFFFFF)
   *
   * @return {string}
   */


  static get DEFAULT_COLOR() {
    return 'default';
  }
  /**
   * Returns the primary color (#5181B8)
   *
   * @return {string}
   */


  static get PRIMARY_COLOR() {
    return 'primary';
  }
  /**
   * Returns the negative color (#E64646)
   *
   * @return {string}
   */


  static get NEGATIVE_COLOR() {
    return 'negative';
  }
  /**
   * Returns the positive color (#4BB34B)
   *
   * @return {string}
   */


  static get POSITIVE_COLOR() {
    return 'positive';
  }
  /**
   * Returns to JSON
   *
   * @return {Object}
   */


  toJSON() {
    return {
      color: this.color,
      action: this.action
    };
  }

}

class TextButton extends Button {
  /**
   * Constructor
   *
   * @param {Object} options
   */
  constructor({
    color,
    label,
    payload
  }) {
    if (label.length > 40) {
      throw new VKError({
        message: 'Maximum length of label 40 characters'
      });
    }

    super({
      color,
      action: {
        type: 'text',
        label,
        payload
      }
    });
  }

}

const {
  DEFAULT_COLOR,
  PRIMARY_COLOR,
  NEGATIVE_COLOR,
  POSITIVE_COLOR
} = Button;
class Keyboard {
  /**
   * Constructor
   *
   * @param {Object} options
   */
  constructor({
    oneTime = false
  } = {}) {
    this.oneTime = oneTime;
    this.buttons = [];
  }
  /**
   * Returns custom tag
   *
   * @return {string}
   */


  get [Symbol.toStringTag]() {
    return 'Keyboard';
  }
  /**
   * Returns the default color
   *
   * @type {string}
   */


  static get DEFAULT_COLOR() {
    return DEFAULT_COLOR;
  }
  /**
   * Returns the primary color
   *
   * @return {string}
   */


  static get PRIMARY_COLOR() {
    return PRIMARY_COLOR;
  }
  /**
   * Returns the negative color
   *
   * @return {string}
   */


  static get NEGATIVE_COLOR() {
    return NEGATIVE_COLOR;
  }
  /**
   * Returns the positive color
   *
   * @return {string}
   */


  static get POSITIVE_COLOR() {
    return POSITIVE_COLOR;
  }
  /**
   * Return keyboard
   *
   * @param {Array}  rows
   * @param {Object} options
   *
   * @return {Keyboard}
   */


  static keyboard(rows, options) {
    if (rows.length > 10) {
      throw new VKError({
        message: 'Max count of keyboard rows 10'
      });
    }

    const keyboard = new Keyboard(options);

    for (const buttons of rows) {
      keyboard.addButtonsRow(buttons);
    }

    return keyboard;
  }
  /**
   * Returns the text button
   *
   * @param {Object} options
   *
   * @return {TextButton}
   */


  static textButton(options) {
    return new TextButton(options);
  }
  /**
   * The keyboard will open only once
   *
   * @return {this}
   */


  oneTime() {
    this.oneTime = true;
    return this;
  }
  /**
   * Add buttons row
   *
   * @param {Button[]} buttons
   */


  addButtonsRow(buttons) {
    if (!Array.isArray(buttons)) {
      buttons = [buttons];
    }

    if (buttons.length > 4) {
      throw new VKError({
        message: 'Max count of buttons at columns 4'
      });
    }

    this.buttons.push(buttons);
    return this;
  }
  /**
   * Returns a string to keyboard a VK
   *
   * @return {string}
   */


  toString() {
    const buttons = this.buttons.map(buttonRow => {
      if (!Array.isArray(buttonRow)) {
        return buttonRow.toJSON();
      }

      return buttonRow.map(button => button.toJSON());
    });
    return JSON.stringify({
      one_time: this.oneTime,
      buttons
    });
  }

}

export default VK;
export { VK, Request, captchaTypes, messageSources, VKError, APIError, AuthError, UploadError, CollectError, UpdatesError, ExecuteError, SnippetsError, StreamingRuleError, apiErrors, authErrors, uploadErrors, updatesErrors, collectErrors, snippetsErrors, Button, Keyboard, TextButton, Context, VoteContext, TypingContext, MessageContext, WallPostContext, StreamingContext, GroupUserContext, UserOnlineContext, GroupUpdateContext, DialogFlagsContext, MessageAllowContext, GroupMemberContext, ReadMessagesContext, MessageFlagsContext, CommentActionContext, NewAttachmentsContext, RemovedMessagesContext, Attachment, ExternalAttachment, GiftAttachment, WallAttachment, LinkAttachment, PhotoAttachment, AudioAttachment, VideoAttachment, MarketAttachment, StickerAttachment, DocumentAttachment, WallReplyAttachment, MarketAlbumAttachment };
